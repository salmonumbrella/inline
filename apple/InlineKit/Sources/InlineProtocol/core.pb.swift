// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Method: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case getMe // = 1
  case sendMessage // = 2
  case getPeerPhoto // = 3
  case deleteMessages // = 4
  case getChatHistory // = 5
  case addReaction // = 6
  case deleteReaction // = 7
  case editMessage // = 8
  case createChat // = 9
  case getSpaceMembers // = 10
  case deleteChat // = 11
  case inviteToSpace // = 12
  case getChatParticipants // = 13
  case addChatParticipant // = 14
  case removeChatParticipant // = 15
  case translateMessages // = 16
  case getChats // = 17
  case updateUserSettings // = 18
  case getUserSettings // = 19
  case sendComposeAction // = 20
  case createBot // = 21
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .getMe
    case 2: self = .sendMessage
    case 3: self = .getPeerPhoto
    case 4: self = .deleteMessages
    case 5: self = .getChatHistory
    case 6: self = .addReaction
    case 7: self = .deleteReaction
    case 8: self = .editMessage
    case 9: self = .createChat
    case 10: self = .getSpaceMembers
    case 11: self = .deleteChat
    case 12: self = .inviteToSpace
    case 13: self = .getChatParticipants
    case 14: self = .addChatParticipant
    case 15: self = .removeChatParticipant
    case 16: self = .translateMessages
    case 17: self = .getChats
    case 18: self = .updateUserSettings
    case 19: self = .getUserSettings
    case 20: self = .sendComposeAction
    case 21: self = .createBot
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .getMe: return 1
    case .sendMessage: return 2
    case .getPeerPhoto: return 3
    case .deleteMessages: return 4
    case .getChatHistory: return 5
    case .addReaction: return 6
    case .deleteReaction: return 7
    case .editMessage: return 8
    case .createChat: return 9
    case .getSpaceMembers: return 10
    case .deleteChat: return 11
    case .inviteToSpace: return 12
    case .getChatParticipants: return 13
    case .addChatParticipant: return 14
    case .removeChatParticipant: return 15
    case .translateMessages: return 16
    case .getChats: return 17
    case .updateUserSettings: return 18
    case .getUserSettings: return 19
    case .sendComposeAction: return 20
    case .createBot: return 21
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Method] = [
    .unspecified,
    .getMe,
    .sendMessage,
    .getPeerPhoto,
    .deleteMessages,
    .getChatHistory,
    .addReaction,
    .deleteReaction,
    .editMessage,
    .createChat,
    .getSpaceMembers,
    .deleteChat,
    .inviteToSpace,
    .getChatParticipants,
    .addChatParticipant,
    .removeChatParticipant,
    .translateMessages,
    .getChats,
    .updateUserSettings,
    .getUserSettings,
    .sendComposeAction,
    .createBot,
  ]

}

public struct ClientMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var seq: UInt32 = 0

  public var body: ClientMessage.OneOf_Body? = nil

  public var connectionInit: ConnectionInit {
    get {
      if case .connectionInit(let v)? = body {return v}
      return ConnectionInit()
    }
    set {body = .connectionInit(newValue)}
  }

  public var rpcCall: RpcCall {
    get {
      if case .rpcCall(let v)? = body {return v}
      return RpcCall()
    }
    set {body = .rpcCall(newValue)}
  }

  public var ack: Ack {
    get {
      if case .ack(let v)? = body {return v}
      return Ack()
    }
    set {body = .ack(newValue)}
  }

  public var ping: Ping {
    get {
      if case .ping(let v)? = body {return v}
      return Ping()
    }
    set {body = .ping(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    case connectionInit(ConnectionInit)
    case rpcCall(RpcCall)
    case ack(Ack)
    case ping(Ping)

  }

  public init() {}
}

public struct ConnectionInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  /// Build number of the client app
  public var buildNumber: Int32 {
    get {return _buildNumber ?? 0}
    set {_buildNumber = newValue}
  }
  /// Returns true if `buildNumber` has been explicitly set.
  public var hasBuildNumber: Bool {return self._buildNumber != nil}
  /// Clears the value of `buildNumber`. Subsequent reads from it will return its default value.
  public mutating func clearBuildNumber() {self._buildNumber = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _buildNumber: Int32? = nil
}

public struct ServerProtocolMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: UInt64 = 0

  public var body: ServerProtocolMessage.OneOf_Body? = nil

  public var connectionOpen: ConnectionOpen {
    get {
      if case .connectionOpen(let v)? = body {return v}
      return ConnectionOpen()
    }
    set {body = .connectionOpen(newValue)}
  }

  public var rpcResult: RpcResult {
    get {
      if case .rpcResult(let v)? = body {return v}
      return RpcResult()
    }
    set {body = .rpcResult(newValue)}
  }

  public var rpcError: RpcError {
    get {
      if case .rpcError(let v)? = body {return v}
      return RpcError()
    }
    set {body = .rpcError(newValue)}
  }

  public var message: ServerMessage {
    get {
      if case .message(let v)? = body {return v}
      return ServerMessage()
    }
    set {body = .message(newValue)}
  }

  public var ack: Ack {
    get {
      if case .ack(let v)? = body {return v}
      return Ack()
    }
    set {body = .ack(newValue)}
  }

  public var pong: Pong {
    get {
      if case .pong(let v)? = body {return v}
      return Pong()
    }
    set {body = .pong(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    case connectionOpen(ConnectionOpen)
    case rpcResult(RpcResult)
    case rpcError(RpcError)
    case message(ServerMessage)
    case ack(Ack)
    case pong(Pong)

  }

  public init() {}
}

public struct ServerMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: ServerMessage.OneOf_Payload? = nil

  public var update: UpdatesPayload {
    get {
      if case .update(let v)? = payload {return v}
      return UpdatesPayload()
    }
    set {payload = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case update(UpdatesPayload)

  }

  public init() {}
}

public struct UpdatesPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msgID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ConnectionOpen: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nonce: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Pong: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nonce: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputPeer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: InputPeer.OneOf_Type? = nil

  public var self_p: InputPeerSelf {
    get {
      if case .self_p(let v)? = type {return v}
      return InputPeerSelf()
    }
    set {type = .self_p(newValue)}
  }

  public var chat: InputPeerChat {
    get {
      if case .chat(let v)? = type {return v}
      return InputPeerChat()
    }
    set {type = .chat(newValue)}
  }

  public var user: InputPeerUser {
    get {
      if case .user(let v)? = type {return v}
      return InputPeerUser()
    }
    set {type = .user(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case self_p(InputPeerSelf)
    case chat(InputPeerChat)
    case user(InputPeerUser)

  }

  public init() {}
}

public struct InputPeerSelf: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputPeerChat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputPeerUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Peer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Peer.OneOf_Type? = nil

  public var chat: PeerChat {
    get {
      if case .chat(let v)? = type {return v}
      return PeerChat()
    }
    set {type = .chat(newValue)}
  }

  public var user: PeerUser {
    get {
      if case .user(let v)? = type {return v}
      return PeerUser()
    }
    set {type = .user(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    case chat(PeerChat)
    case user(PeerUser)

  }

  public init() {}
}

public struct PeerChat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PeerUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct User: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var firstName: String {
    get {return _firstName ?? String()}
    set {_firstName = newValue}
  }
  /// Returns true if `firstName` has been explicitly set.
  public var hasFirstName: Bool {return self._firstName != nil}
  /// Clears the value of `firstName`. Subsequent reads from it will return its default value.
  public mutating func clearFirstName() {self._firstName = nil}

  public var lastName: String {
    get {return _lastName ?? String()}
    set {_lastName = newValue}
  }
  /// Returns true if `lastName` has been explicitly set.
  public var hasLastName: Bool {return self._lastName != nil}
  /// Clears the value of `lastName`. Subsequent reads from it will return its default value.
  public mutating func clearLastName() {self._lastName = nil}

  public var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  public var phoneNumber: String {
    get {return _phoneNumber ?? String()}
    set {_phoneNumber = newValue}
  }
  /// Returns true if `phoneNumber` has been explicitly set.
  public var hasPhoneNumber: Bool {return self._phoneNumber != nil}
  /// Clears the value of `phoneNumber`. Subsequent reads from it will return its default value.
  public mutating func clearPhoneNumber() {self._phoneNumber = nil}

  public var email: String {
    get {return _email ?? String()}
    set {_email = newValue}
  }
  /// Returns true if `email` has been explicitly set.
  public var hasEmail: Bool {return self._email != nil}
  /// Clears the value of `email`. Subsequent reads from it will return its default value.
  public mutating func clearEmail() {self._email = nil}

  /// If true, certain fields such as email or phone_number will be missing
  public var min: Bool {
    get {return _min ?? false}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  public var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  public mutating func clearMin() {self._min = nil}

  public var status: UserStatus {
    get {return _status ?? UserStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var profilePhoto: UserProfilePhoto {
    get {return _profilePhoto ?? UserProfilePhoto()}
    set {_profilePhoto = newValue}
  }
  /// Returns true if `profilePhoto` has been explicitly set.
  public var hasProfilePhoto: Bool {return self._profilePhoto != nil}
  /// Clears the value of `profilePhoto`. Subsequent reads from it will return its default value.
  public mutating func clearProfilePhoto() {self._profilePhoto = nil}

  /// If true, the user has not completed the setup process
  public var pendingSetup: Bool {
    get {return _pendingSetup ?? false}
    set {_pendingSetup = newValue}
  }
  /// Returns true if `pendingSetup` has been explicitly set.
  public var hasPendingSetup: Bool {return self._pendingSetup != nil}
  /// Clears the value of `pendingSetup`. Subsequent reads from it will return its default value.
  public mutating func clearPendingSetup() {self._pendingSetup = nil}

  public var timeZone: String {
    get {return _timeZone ?? String()}
    set {_timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  public var hasTimeZone: Bool {return self._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  public mutating func clearTimeZone() {self._timeZone = nil}

  public var bot: Bool {
    get {return _bot ?? false}
    set {_bot = newValue}
  }
  /// Returns true if `bot` has been explicitly set.
  public var hasBot: Bool {return self._bot != nil}
  /// Clears the value of `bot`. Subsequent reads from it will return its default value.
  public mutating func clearBot() {self._bot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _firstName: String? = nil
  fileprivate var _lastName: String? = nil
  fileprivate var _username: String? = nil
  fileprivate var _phoneNumber: String? = nil
  fileprivate var _email: String? = nil
  fileprivate var _min: Bool? = nil
  fileprivate var _status: UserStatus? = nil
  fileprivate var _profilePhoto: UserProfilePhoto? = nil
  fileprivate var _pendingSetup: Bool? = nil
  fileprivate var _timeZone: String? = nil
  fileprivate var _bot: Bool? = nil
}

public struct UserProfilePhoto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the photo
  public var photoID: Int64 {
    get {return _photoID ?? 0}
    set {_photoID = newValue}
  }
  /// Returns true if `photoID` has been explicitly set.
  public var hasPhotoID: Bool {return self._photoID != nil}
  /// Clears the value of `photoID`. Subsequent reads from it will return its default value.
  public mutating func clearPhotoID() {self._photoID = nil}

  /// Stripped thumbnail of the photo
  public var strippedThumb: Data {
    get {return _strippedThumb ?? Data()}
    set {_strippedThumb = newValue}
  }
  /// Returns true if `strippedThumb` has been explicitly set.
  public var hasStrippedThumb: Bool {return self._strippedThumb != nil}
  /// Clears the value of `strippedThumb`. Subsequent reads from it will return its default value.
  public mutating func clearStrippedThumb() {self._strippedThumb = nil}

  /// Photo
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photoID: Int64? = nil
  fileprivate var _strippedThumb: Data? = nil
  fileprivate var _cdnURL: String? = nil
}

public struct Dialog: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peer: Peer {
    get {return _peer ?? Peer()}
    set {_peer = newValue}
  }
  /// Returns true if `peer` has been explicitly set.
  public var hasPeer: Bool {return self._peer != nil}
  /// Clears the value of `peer`. Subsequent reads from it will return its default value.
  public mutating func clearPeer() {self._peer = nil}

  public var spaceID: Int64 {
    get {return _spaceID ?? 0}
    set {_spaceID = newValue}
  }
  /// Returns true if `spaceID` has been explicitly set.
  public var hasSpaceID: Bool {return self._spaceID != nil}
  /// Clears the value of `spaceID`. Subsequent reads from it will return its default value.
  public mutating func clearSpaceID() {self._spaceID = nil}

  public var archived: Bool {
    get {return _archived ?? false}
    set {_archived = newValue}
  }
  /// Returns true if `archived` has been explicitly set.
  public var hasArchived: Bool {return self._archived != nil}
  /// Clears the value of `archived`. Subsequent reads from it will return its default value.
  public mutating func clearArchived() {self._archived = nil}

  public var pinned: Bool {
    get {return _pinned ?? false}
    set {_pinned = newValue}
  }
  /// Returns true if `pinned` has been explicitly set.
  public var hasPinned: Bool {return self._pinned != nil}
  /// Clears the value of `pinned`. Subsequent reads from it will return its default value.
  public mutating func clearPinned() {self._pinned = nil}

  public var readMaxID: Int64 {
    get {return _readMaxID ?? 0}
    set {_readMaxID = newValue}
  }
  /// Returns true if `readMaxID` has been explicitly set.
  public var hasReadMaxID: Bool {return self._readMaxID != nil}
  /// Clears the value of `readMaxID`. Subsequent reads from it will return its default value.
  public mutating func clearReadMaxID() {self._readMaxID = nil}

  public var unreadCount: Int32 {
    get {return _unreadCount ?? 0}
    set {_unreadCount = newValue}
  }
  /// Returns true if `unreadCount` has been explicitly set.
  public var hasUnreadCount: Bool {return self._unreadCount != nil}
  /// Clears the value of `unreadCount`. Subsequent reads from it will return its default value.
  public mutating func clearUnreadCount() {self._unreadCount = nil}

  public var chatID: Int64 {
    get {return _chatID ?? 0}
    set {_chatID = newValue}
  }
  /// Returns true if `chatID` has been explicitly set.
  public var hasChatID: Bool {return self._chatID != nil}
  /// Clears the value of `chatID`. Subsequent reads from it will return its default value.
  public mutating func clearChatID() {self._chatID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peer: Peer? = nil
  fileprivate var _spaceID: Int64? = nil
  fileprivate var _archived: Bool? = nil
  fileprivate var _pinned: Bool? = nil
  fileprivate var _readMaxID: Int64? = nil
  fileprivate var _unreadCount: Int32? = nil
  fileprivate var _chatID: Int64? = nil
}

/// A thread
public struct Chat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// Title
  public var title: String = String()

  /// If it belongs to a space
  public var spaceID: Int64 {
    get {return _spaceID ?? 0}
    set {_spaceID = newValue}
  }
  /// Returns true if `spaceID` has been explicitly set.
  public var hasSpaceID: Bool {return self._spaceID != nil}
  /// Clears the value of `spaceID`. Subsequent reads from it will return its default value.
  public mutating func clearSpaceID() {self._spaceID = nil}

  /// Optional description
  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  /// Emoji to show as the icon, can be null
  public var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {self._emoji = nil}

  /// If true, everyone in parent space can accces it
  public var isPublic: Bool {
    get {return _isPublic ?? false}
    set {_isPublic = newValue}
  }
  /// Returns true if `isPublic` has been explicitly set.
  public var hasIsPublic: Bool {return self._isPublic != nil}
  /// Clears the value of `isPublic`. Subsequent reads from it will return its default value.
  public mutating func clearIsPublic() {self._isPublic = nil}

  /// Last message ID
  public var lastMsgID: Int64 {
    get {return _lastMsgID ?? 0}
    set {_lastMsgID = newValue}
  }
  /// Returns true if `lastMsgID` has been explicitly set.
  public var hasLastMsgID: Bool {return self._lastMsgID != nil}
  /// Clears the value of `lastMsgID`. Subsequent reads from it will return its default value.
  public mutating func clearLastMsgID() {self._lastMsgID = nil}

  /// ID of the peer that this chat belongs to
  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Date of creation
  public var date: Int64 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spaceID: Int64? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _emoji: String? = nil
  fileprivate var _isPublic: Bool? = nil
  fileprivate var _lastMsgID: Int64? = nil
  fileprivate var _peerID: Peer? = nil
  fileprivate var _date: Int64? = nil
}

public struct Message: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// User ID of the sender
  public var fromID: Int64 {
    get {return _storage._fromID}
    set {_uniqueStorage()._fromID = newValue}
  }

  /// Peer ID of the recipient
  public var peerID: Peer {
    get {return _storage._peerID ?? Peer()}
    set {_uniqueStorage()._peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return _storage._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {_uniqueStorage()._peerID = nil}

  /// The "chat ID" of the message, for messages in a chat (deprecated)
  public var chatID: Int64 {
    get {return _storage._chatID}
    set {_uniqueStorage()._chatID = newValue}
  }

  /// Message text
  public var message: String {
    get {return _storage._message ?? String()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {_uniqueStorage()._message = nil}

  /// Whether the message is outgoing
  public var out: Bool {
    get {return _storage._out}
    set {_uniqueStorage()._out = newValue}
  }

  /// Date of the message
  public var date: Int64 {
    get {return _storage._date}
    set {_uniqueStorage()._date = newValue}
  }

  /// Whether user is mentioned
  public var mentioned: Bool {
    get {return _storage._mentioned ?? false}
    set {_uniqueStorage()._mentioned = newValue}
  }
  /// Returns true if `mentioned` has been explicitly set.
  public var hasMentioned: Bool {return _storage._mentioned != nil}
  /// Clears the value of `mentioned`. Subsequent reads from it will return its default value.
  public mutating func clearMentioned() {_uniqueStorage()._mentioned = nil}

  /// Message ID of the message being replied to
  public var replyToMsgID: Int64 {
    get {return _storage._replyToMsgID ?? 0}
    set {_uniqueStorage()._replyToMsgID = newValue}
  }
  /// Returns true if `replyToMsgID` has been explicitly set.
  public var hasReplyToMsgID: Bool {return _storage._replyToMsgID != nil}
  /// Clears the value of `replyToMsgID`. Subsequent reads from it will return its default value.
  public mutating func clearReplyToMsgID() {_uniqueStorage()._replyToMsgID = nil}

  /// Media of the message
  public var media: MessageMedia {
    get {return _storage._media ?? MessageMedia()}
    set {_uniqueStorage()._media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {return _storage._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {_uniqueStorage()._media = nil}

  /// Date of the last edit if edited
  public var editDate: Int64 {
    get {return _storage._editDate ?? 0}
    set {_uniqueStorage()._editDate = newValue}
  }
  /// Returns true if `editDate` has been explicitly set.
  public var hasEditDate: Bool {return _storage._editDate != nil}
  /// Clears the value of `editDate`. Subsequent reads from it will return its default value.
  public mutating func clearEditDate() {_uniqueStorage()._editDate = nil}

  /// ID of the grouped message if it's part of an album
  public var groupedID: Int64 {
    get {return _storage._groupedID ?? 0}
    set {_uniqueStorage()._groupedID = newValue}
  }
  /// Returns true if `groupedID` has been explicitly set.
  public var hasGroupedID: Bool {return _storage._groupedID != nil}
  /// Clears the value of `groupedID`. Subsequent reads from it will return its default value.
  public mutating func clearGroupedID() {_uniqueStorage()._groupedID = nil}

  /// Attachments of the message
  public var attachments: MessageAttachments {
    get {return _storage._attachments ?? MessageAttachments()}
    set {_uniqueStorage()._attachments = newValue}
  }
  /// Returns true if `attachments` has been explicitly set.
  public var hasAttachments: Bool {return _storage._attachments != nil}
  /// Clears the value of `attachments`. Subsequent reads from it will return its default value.
  public mutating func clearAttachments() {_uniqueStorage()._attachments = nil}

  /// Reactions of the message
  public var reactions: MessageReactions {
    get {return _storage._reactions ?? MessageReactions()}
    set {_uniqueStorage()._reactions = newValue}
  }
  /// Returns true if `reactions` has been explicitly set.
  public var hasReactions: Bool {return _storage._reactions != nil}
  /// Clears the value of `reactions`. Subsequent reads from it will return its default value.
  public mutating func clearReactions() {_uniqueStorage()._reactions = nil}

  /// Whether the message is a sticker
  public var isSticker: Bool {
    get {return _storage._isSticker ?? false}
    set {_uniqueStorage()._isSticker = newValue}
  }
  /// Returns true if `isSticker` has been explicitly set.
  public var hasIsSticker: Bool {return _storage._isSticker != nil}
  /// Clears the value of `isSticker`. Subsequent reads from it will return its default value.
  public mutating func clearIsSticker() {_uniqueStorage()._isSticker = nil}

  /// Rich text entities
  public var entities: MessageEntities {
    get {return _storage._entities ?? MessageEntities()}
    set {_uniqueStorage()._entities = newValue}
  }
  /// Returns true if `entities` has been explicitly set.
  public var hasEntities: Bool {return _storage._entities != nil}
  /// Clears the value of `entities`. Subsequent reads from it will return its default value.
  public mutating func clearEntities() {_uniqueStorage()._entities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct MessageEntities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entities: [MessageEntity] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MessageEntity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: MessageEntity.TypeEnum = .unspecified

  public var offset: Int64 = 0

  public var length: Int64 = 0

  public var entity: MessageEntity.OneOf_Entity? = nil

  public var mention: MessageEntity.MessageEntityMention {
    get {
      if case .mention(let v)? = entity {return v}
      return MessageEntity.MessageEntityMention()
    }
    set {entity = .mention(newValue)}
  }

  public var textURL: MessageEntity.MessageEntityTextUrl {
    get {
      if case .textURL(let v)? = entity {return v}
      return MessageEntity.MessageEntityTextUrl()
    }
    set {entity = .textURL(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Entity: Equatable, Sendable {
    case mention(MessageEntity.MessageEntityMention)
    case textURL(MessageEntity.MessageEntityTextUrl)

  }

  public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case mention // = 1
    case url // = 2
    case textURL // = 3
    case email // = 4
    case bold // = 5
    case italic // = 6
    case usernameMention // = 7
    case code // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .mention
      case 2: self = .url
      case 3: self = .textURL
      case 4: self = .email
      case 5: self = .bold
      case 6: self = .italic
      case 7: self = .usernameMention
      case 8: self = .code
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .mention: return 1
      case .url: return 2
      case .textURL: return 3
      case .email: return 4
      case .bold: return 5
      case .italic: return 6
      case .usernameMention: return 7
      case .code: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [MessageEntity.TypeEnum] = [
      .unspecified,
      .mention,
      .url,
      .textURL,
      .email,
      .bold,
      .italic,
      .usernameMention,
      .code,
    ]

  }

  public struct MessageEntityMention: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MessageEntityTextUrl: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct MessageReactions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reactions of the message
  public var reactions: [Reaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Reaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Emoji of the reaction
  public var emoji: String = String()

  /// ID of the user who reacted
  public var userID: Int64 = 0

  /// ID of the message that this reaction is for
  public var messageID: Int64 = 0

  /// ID of the chat that this reaction is for
  public var chatID: Int64 = 0

  /// Date of the reaction
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Member: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var spaceID: Int64 = 0

  public var userID: Int64 = 0

  public var role: Member.Role {
    get {return _role ?? .owner}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  /// Date of joining
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Role: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case owner // = 0
    case admin // = 1
    case member // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .owner
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .owner
      case 1: self = .admin
      case 2: self = .member
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .owner: return 0
      case .admin: return 1
      case .member: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Member.Role] = [
      .owner,
      .admin,
      .member,
    ]

  }

  public init() {}

  fileprivate var _role: Member.Role? = nil
}

public struct Space: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID
  public var id: Int64 = 0

  /// Name of the space
  public var name: String = String()

  /// Whether the current user is the creator of the space
  public var creator: Bool = false

  /// Date of creation
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Add reaction input
public struct AddReactionInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Emoji of the reaction
  public var emoji: String = String()

  /// ID of the message that this reaction is for
  public var messageID: Int64 = 0

  /// ID of the peer that this reaction is for
  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

/// Add reaction result
public struct AddReactionResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Delete reaction input
public struct DeleteReactionInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var emoji: String = String()

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var messageID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct DeleteReactionResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MessageAttachments: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachments: [MessageAttachment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MessageAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID
  public var id: Int64 = 0

  public var attachment: MessageAttachment.OneOf_Attachment? = nil

  public var externalTask: MessageAttachmentExternalTask {
    get {
      if case .externalTask(let v)? = attachment {return v}
      return MessageAttachmentExternalTask()
    }
    set {attachment = .externalTask(newValue)}
  }

  public var urlPreview: UrlPreview {
    get {
      if case .urlPreview(let v)? = attachment {return v}
      return UrlPreview()
    }
    set {attachment = .urlPreview(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Attachment: Equatable, Sendable {
    case externalTask(MessageAttachmentExternalTask)
    case urlPreview(UrlPreview)

  }

  public init() {}
}

public struct UrlPreview: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of external task in our database
  public var id: Int64 = 0

  /// URL of the link
  public var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  /// Site name of the link
  public var siteName: String {
    get {return _siteName ?? String()}
    set {_siteName = newValue}
  }
  /// Returns true if `siteName` has been explicitly set.
  public var hasSiteName: Bool {return self._siteName != nil}
  /// Clears the value of `siteName`. Subsequent reads from it will return its default value.
  public mutating func clearSiteName() {self._siteName = nil}

  /// Title of the link
  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  /// Description of the link
  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  /// Image ID of the link
  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  /// Duration of the content
  public var duration: Int64 {
    get {return _duration ?? 0}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _url: String? = nil
  fileprivate var _siteName: String? = nil
  fileprivate var _title: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _photo: Photo? = nil
  fileprivate var _duration: Int64? = nil
}

public struct MessageAttachmentExternalTask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of external task in our database
  public var id: Int64 = 0

  /// ID of the task in the external application
  public var taskID: String = String()

  /// Application name
  public var application: String = String()

  /// Title of the task/issue
  public var title: String = String()

  /// Status of the task
  public var status: MessageAttachmentExternalTask.Status = .unspecified

  /// Assigned user ID in Inline
  public var assignedUserID: Int64 = 0

  /// URL of the task/issue in the external application
  public var url: String = String()

  /// Number/code of the task/issue in the external application
  public var number: String = String()

  /// Date of creation/addition in Inline
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case backlog // = 1
    case todo // = 2
    case inProgress // = 3
    case done // = 4
    case cancelled // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .backlog
      case 2: self = .todo
      case 3: self = .inProgress
      case 4: self = .done
      case 5: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .backlog: return 1
      case .todo: return 2
      case .inProgress: return 3
      case .done: return 4
      case .cancelled: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [MessageAttachmentExternalTask.Status] = [
      .unspecified,
      .backlog,
      .todo,
      .inProgress,
      .done,
      .cancelled,
    ]

  }

  public init() {}
}

/// WIP: add document, audio, video.
public struct MessageMedia: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var media: MessageMedia.OneOf_Media? = nil

  public var photo: MessagePhoto {
    get {
      if case .photo(let v)? = media {return v}
      return MessagePhoto()
    }
    set {media = .photo(newValue)}
  }

  public var video: MessageVideo {
    get {
      if case .video(let v)? = media {return v}
      return MessageVideo()
    }
    set {media = .video(newValue)}
  }

  public var document: MessageDocument {
    get {
      if case .document(let v)? = media {return v}
      return MessageDocument()
    }
    set {media = .document(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Media: Equatable, Sendable {
    case photo(MessagePhoto)
    case video(MessageVideo)
    case document(MessageDocument)

  }

  public init() {}
}

public struct MessagePhoto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photo: Photo? = nil
}

public struct MessageVideo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var video: Video {
    get {return _video ?? Video()}
    set {_video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return self._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {self._video = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _video: Video? = nil
}

public struct MessageDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var document: Document {
    get {return _document ?? Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Document? = nil
}

public struct Video: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// Date of upload
  public var date: Int64 = 0

  /// Width of the video
  public var w: Int32 = 0

  /// Height of the video
  public var h: Int32 = 0

  /// Duration of the video in seconds
  public var duration: Int32 = 0

  /// File size
  public var size: Int32 = 0

  /// Thumbnail of the video
  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  /// CDN URL
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photo: Photo? = nil
  fileprivate var _cdnURL: String? = nil
}

public struct Document: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// Original file name
  public var fileName: String = String()

  /// MIME type of the file
  public var mimeType: String = String()

  /// File size
  public var size: Int32 = 0

  /// CDN URL
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  /// Date of upload
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cdnURL: String? = nil
}

/// Photo for message media, profile photo, space photo, or chat photo
public struct Photo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID
  public var id: Int64 = 0

  /// Date of upload
  public var date: Int64 = 0

  public var sizes: [PhotoSize] = []

  /// Format of the photo
  public var format: Photo.Format = .unspecified

  /// Unique identifier of the file
  public var fileUniqueID: String {
    get {return _fileUniqueID ?? String()}
    set {_fileUniqueID = newValue}
  }
  /// Returns true if `fileUniqueID` has been explicitly set.
  public var hasFileUniqueID: Bool {return self._fileUniqueID != nil}
  /// Clears the value of `fileUniqueID`. Subsequent reads from it will return its default value.
  public mutating func clearFileUniqueID() {self._fileUniqueID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Format: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case jpeg // = 1
    case png // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .jpeg
      case 2: self = .png
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .jpeg: return 1
      case .png: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Photo.Format] = [
      .unspecified,
      .jpeg,
      .png,
    ]

  }

  public init() {}

  fileprivate var _fileUniqueID: String? = nil
}

public struct PhotoSize: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///* Thumbnail type.
  ///Currently supported:
  ///- "b" - small box 140x140
  ///- "c" - medium box 320x320
  ///- "d" - regular box 800x800
  ///- "f" - large box 2560x2560
  ///- "s" - stripped (tiny version embedded in bytes)
  ///- "y" - ??
  ///- "x" - small cropped ??
  ///- "w" - medium cropped ??
  ///- "v" - ??
  public var type: String = String()

  /// Width in pixels
  public var w: Int32 = 0

  /// Height in pixels
  public var h: Int32 = 0

  /// File size
  public var size: Int32 = 0

  /// Bytes for stripped size used in blur thumbnails
  public var bytes: Data {
    get {return _bytes ?? Data()}
    set {_bytes = newValue}
  }
  /// Returns true if `bytes` has been explicitly set.
  public var hasBytes: Bool {return self._bytes != nil}
  /// Clears the value of `bytes`. Subsequent reads from it will return its default value.
  public mutating func clearBytes() {self._bytes = nil}

  /// CDN URL
  public var cdnURL: String {
    get {return _cdnURL ?? String()}
    set {_cdnURL = newValue}
  }
  /// Returns true if `cdnURL` has been explicitly set.
  public var hasCdnURL: Bool {return self._cdnURL != nil}
  /// Clears the value of `cdnURL`. Subsequent reads from it will return its default value.
  public mutating func clearCdnURL() {self._cdnURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bytes: Data? = nil
  fileprivate var _cdnURL: String? = nil
}

public struct RpcError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reqMsgID: UInt64 = 0

  public var errorCode: RpcError.Code = .unknown

  public var message: String = String()

  public var code: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of error
  public enum Code: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case badRequest // = 1
    case unauthenticated // = 2
    case rateLimit // = 3
    case internalError // = 4
    case peerIDInvalid // = 5
    case messageIDInvalid // = 6
    case userIDInvalid // = 7
    case userAlreadyMember // = 8
    case spaceIDInvalid // = 9
    case chatIDInvalid // = 10
    case emailInvalid // = 11
    case phoneNumberInvalid // = 12
    case spaceAdminRequired // = 13
    case spaceOwnerRequired // = 14
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .badRequest
      case 2: self = .unauthenticated
      case 3: self = .rateLimit
      case 4: self = .internalError
      case 5: self = .peerIDInvalid
      case 6: self = .messageIDInvalid
      case 7: self = .userIDInvalid
      case 8: self = .userAlreadyMember
      case 9: self = .spaceIDInvalid
      case 10: self = .chatIDInvalid
      case 11: self = .emailInvalid
      case 12: self = .phoneNumberInvalid
      case 13: self = .spaceAdminRequired
      case 14: self = .spaceOwnerRequired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .badRequest: return 1
      case .unauthenticated: return 2
      case .rateLimit: return 3
      case .internalError: return 4
      case .peerIDInvalid: return 5
      case .messageIDInvalid: return 6
      case .userIDInvalid: return 7
      case .userAlreadyMember: return 8
      case .spaceIDInvalid: return 9
      case .chatIDInvalid: return 10
      case .emailInvalid: return 11
      case .phoneNumberInvalid: return 12
      case .spaceAdminRequired: return 13
      case .spaceOwnerRequired: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [RpcError.Code] = [
      .unknown,
      .badRequest,
      .unauthenticated,
      .rateLimit,
      .internalError,
      .peerIDInvalid,
      .messageIDInvalid,
      .userIDInvalid,
      .userAlreadyMember,
      .spaceIDInvalid,
      .chatIDInvalid,
      .emailInvalid,
      .phoneNumberInvalid,
      .spaceAdminRequired,
      .spaceOwnerRequired,
    ]

  }

  public init() {}
}

public struct RpcCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Method = .unspecified

  public var input: RpcCall.OneOf_Input? = nil

  public var getMe: GetMeInput {
    get {
      if case .getMe(let v)? = input {return v}
      return GetMeInput()
    }
    set {input = .getMe(newValue)}
  }

  public var getPeerPhoto: GetPeerPhotoInput {
    get {
      if case .getPeerPhoto(let v)? = input {return v}
      return GetPeerPhotoInput()
    }
    set {input = .getPeerPhoto(newValue)}
  }

  public var deleteMessages: DeleteMessagesInput {
    get {
      if case .deleteMessages(let v)? = input {return v}
      return DeleteMessagesInput()
    }
    set {input = .deleteMessages(newValue)}
  }

  public var sendMessage: SendMessageInput {
    get {
      if case .sendMessage(let v)? = input {return v}
      return SendMessageInput()
    }
    set {input = .sendMessage(newValue)}
  }

  public var getChatHistory: GetChatHistoryInput {
    get {
      if case .getChatHistory(let v)? = input {return v}
      return GetChatHistoryInput()
    }
    set {input = .getChatHistory(newValue)}
  }

  public var addReaction: AddReactionInput {
    get {
      if case .addReaction(let v)? = input {return v}
      return AddReactionInput()
    }
    set {input = .addReaction(newValue)}
  }

  public var deleteReaction: DeleteReactionInput {
    get {
      if case .deleteReaction(let v)? = input {return v}
      return DeleteReactionInput()
    }
    set {input = .deleteReaction(newValue)}
  }

  public var editMessage: EditMessageInput {
    get {
      if case .editMessage(let v)? = input {return v}
      return EditMessageInput()
    }
    set {input = .editMessage(newValue)}
  }

  public var createChat: CreateChatInput {
    get {
      if case .createChat(let v)? = input {return v}
      return CreateChatInput()
    }
    set {input = .createChat(newValue)}
  }

  public var getSpaceMembers: GetSpaceMembersInput {
    get {
      if case .getSpaceMembers(let v)? = input {return v}
      return GetSpaceMembersInput()
    }
    set {input = .getSpaceMembers(newValue)}
  }

  public var deleteChat: DeleteChatInput {
    get {
      if case .deleteChat(let v)? = input {return v}
      return DeleteChatInput()
    }
    set {input = .deleteChat(newValue)}
  }

  public var inviteToSpace: InviteToSpaceInput {
    get {
      if case .inviteToSpace(let v)? = input {return v}
      return InviteToSpaceInput()
    }
    set {input = .inviteToSpace(newValue)}
  }

  public var getChatParticipants: GetChatParticipantsInput {
    get {
      if case .getChatParticipants(let v)? = input {return v}
      return GetChatParticipantsInput()
    }
    set {input = .getChatParticipants(newValue)}
  }

  public var addChatParticipant: AddChatParticipantInput {
    get {
      if case .addChatParticipant(let v)? = input {return v}
      return AddChatParticipantInput()
    }
    set {input = .addChatParticipant(newValue)}
  }

  public var removeChatParticipant: RemoveChatParticipantInput {
    get {
      if case .removeChatParticipant(let v)? = input {return v}
      return RemoveChatParticipantInput()
    }
    set {input = .removeChatParticipant(newValue)}
  }

  public var translateMessages: TranslateMessagesInput {
    get {
      if case .translateMessages(let v)? = input {return v}
      return TranslateMessagesInput()
    }
    set {input = .translateMessages(newValue)}
  }

  public var getChats: GetChatsInput {
    get {
      if case .getChats(let v)? = input {return v}
      return GetChatsInput()
    }
    set {input = .getChats(newValue)}
  }

  public var updateUserSettings: UpdateUserSettingsInput {
    get {
      if case .updateUserSettings(let v)? = input {return v}
      return UpdateUserSettingsInput()
    }
    set {input = .updateUserSettings(newValue)}
  }

  public var getUserSettings: GetUserSettingsInput {
    get {
      if case .getUserSettings(let v)? = input {return v}
      return GetUserSettingsInput()
    }
    set {input = .getUserSettings(newValue)}
  }

  public var sendComposeAction: SendComposeActionInput {
    get {
      if case .sendComposeAction(let v)? = input {return v}
      return SendComposeActionInput()
    }
    set {input = .sendComposeAction(newValue)}
  }

  public var createBot: CreateBotInput {
    get {
      if case .createBot(let v)? = input {return v}
      return CreateBotInput()
    }
    set {input = .createBot(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Input: Equatable, Sendable {
    case getMe(GetMeInput)
    case getPeerPhoto(GetPeerPhotoInput)
    case deleteMessages(DeleteMessagesInput)
    case sendMessage(SendMessageInput)
    case getChatHistory(GetChatHistoryInput)
    case addReaction(AddReactionInput)
    case deleteReaction(DeleteReactionInput)
    case editMessage(EditMessageInput)
    case createChat(CreateChatInput)
    case getSpaceMembers(GetSpaceMembersInput)
    case deleteChat(DeleteChatInput)
    case inviteToSpace(InviteToSpaceInput)
    case getChatParticipants(GetChatParticipantsInput)
    case addChatParticipant(AddChatParticipantInput)
    case removeChatParticipant(RemoveChatParticipantInput)
    case translateMessages(TranslateMessagesInput)
    case getChats(GetChatsInput)
    case updateUserSettings(UpdateUserSettingsInput)
    case getUserSettings(GetUserSettingsInput)
    case sendComposeAction(SendComposeActionInput)
    case createBot(CreateBotInput)

  }

  public init() {}
}

public struct RpcResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reqMsgID: UInt64 {
    get {return _storage._reqMsgID}
    set {_uniqueStorage()._reqMsgID = newValue}
  }

  public var result: OneOf_Result? {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var getMe: GetMeResult {
    get {
      if case .getMe(let v)? = _storage._result {return v}
      return GetMeResult()
    }
    set {_uniqueStorage()._result = .getMe(newValue)}
  }

  public var getPeerPhoto: GetPeerPhotoResult {
    get {
      if case .getPeerPhoto(let v)? = _storage._result {return v}
      return GetPeerPhotoResult()
    }
    set {_uniqueStorage()._result = .getPeerPhoto(newValue)}
  }

  public var deleteMessages: DeleteMessagesResult {
    get {
      if case .deleteMessages(let v)? = _storage._result {return v}
      return DeleteMessagesResult()
    }
    set {_uniqueStorage()._result = .deleteMessages(newValue)}
  }

  public var sendMessage: SendMessageResult {
    get {
      if case .sendMessage(let v)? = _storage._result {return v}
      return SendMessageResult()
    }
    set {_uniqueStorage()._result = .sendMessage(newValue)}
  }

  public var getChatHistory: GetChatHistoryResult {
    get {
      if case .getChatHistory(let v)? = _storage._result {return v}
      return GetChatHistoryResult()
    }
    set {_uniqueStorage()._result = .getChatHistory(newValue)}
  }

  public var addReaction: AddReactionResult {
    get {
      if case .addReaction(let v)? = _storage._result {return v}
      return AddReactionResult()
    }
    set {_uniqueStorage()._result = .addReaction(newValue)}
  }

  public var deleteReaction: DeleteReactionResult {
    get {
      if case .deleteReaction(let v)? = _storage._result {return v}
      return DeleteReactionResult()
    }
    set {_uniqueStorage()._result = .deleteReaction(newValue)}
  }

  public var editMessage: EditMessageResult {
    get {
      if case .editMessage(let v)? = _storage._result {return v}
      return EditMessageResult()
    }
    set {_uniqueStorage()._result = .editMessage(newValue)}
  }

  public var createChat: CreateChatResult {
    get {
      if case .createChat(let v)? = _storage._result {return v}
      return CreateChatResult()
    }
    set {_uniqueStorage()._result = .createChat(newValue)}
  }

  public var getSpaceMembers: GetSpaceMembersResult {
    get {
      if case .getSpaceMembers(let v)? = _storage._result {return v}
      return GetSpaceMembersResult()
    }
    set {_uniqueStorage()._result = .getSpaceMembers(newValue)}
  }

  public var deleteChat: DeleteChatResult {
    get {
      if case .deleteChat(let v)? = _storage._result {return v}
      return DeleteChatResult()
    }
    set {_uniqueStorage()._result = .deleteChat(newValue)}
  }

  public var inviteToSpace: InviteToSpaceResult {
    get {
      if case .inviteToSpace(let v)? = _storage._result {return v}
      return InviteToSpaceResult()
    }
    set {_uniqueStorage()._result = .inviteToSpace(newValue)}
  }

  public var getChatParticipants: GetChatParticipantsResult {
    get {
      if case .getChatParticipants(let v)? = _storage._result {return v}
      return GetChatParticipantsResult()
    }
    set {_uniqueStorage()._result = .getChatParticipants(newValue)}
  }

  public var addChatParticipant: AddChatParticipantResult {
    get {
      if case .addChatParticipant(let v)? = _storage._result {return v}
      return AddChatParticipantResult()
    }
    set {_uniqueStorage()._result = .addChatParticipant(newValue)}
  }

  public var removeChatParticipant: RemoveChatParticipantResult {
    get {
      if case .removeChatParticipant(let v)? = _storage._result {return v}
      return RemoveChatParticipantResult()
    }
    set {_uniqueStorage()._result = .removeChatParticipant(newValue)}
  }

  public var translateMessages: TranslateMessagesResult {
    get {
      if case .translateMessages(let v)? = _storage._result {return v}
      return TranslateMessagesResult()
    }
    set {_uniqueStorage()._result = .translateMessages(newValue)}
  }

  public var getChats: GetChatsResult {
    get {
      if case .getChats(let v)? = _storage._result {return v}
      return GetChatsResult()
    }
    set {_uniqueStorage()._result = .getChats(newValue)}
  }

  public var updateUserSettings: UpdateUserSettingsResult {
    get {
      if case .updateUserSettings(let v)? = _storage._result {return v}
      return UpdateUserSettingsResult()
    }
    set {_uniqueStorage()._result = .updateUserSettings(newValue)}
  }

  public var getUserSettings: GetUserSettingsResult {
    get {
      if case .getUserSettings(let v)? = _storage._result {return v}
      return GetUserSettingsResult()
    }
    set {_uniqueStorage()._result = .getUserSettings(newValue)}
  }

  public var sendComposeAction: SendComposeActionResult {
    get {
      if case .sendComposeAction(let v)? = _storage._result {return v}
      return SendComposeActionResult()
    }
    set {_uniqueStorage()._result = .sendComposeAction(newValue)}
  }

  public var createBot: CreateBotResult {
    get {
      if case .createBot(let v)? = _storage._result {return v}
      return CreateBotResult()
    }
    set {_uniqueStorage()._result = .createBot(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable, Sendable {
    case getMe(GetMeResult)
    case getPeerPhoto(GetPeerPhotoResult)
    case deleteMessages(DeleteMessagesResult)
    case sendMessage(SendMessageResult)
    case getChatHistory(GetChatHistoryResult)
    case addReaction(AddReactionResult)
    case deleteReaction(DeleteReactionResult)
    case editMessage(EditMessageResult)
    case createChat(CreateChatResult)
    case getSpaceMembers(GetSpaceMembersResult)
    case deleteChat(DeleteChatResult)
    case inviteToSpace(InviteToSpaceResult)
    case getChatParticipants(GetChatParticipantsResult)
    case addChatParticipant(AddChatParticipantResult)
    case removeChatParticipant(RemoveChatParticipantResult)
    case translateMessages(TranslateMessagesResult)
    case getChats(GetChatsResult)
    case updateUserSettings(UpdateUserSettingsResult)
    case getUserSettings(GetUserSettingsResult)
    case sendComposeAction(SendComposeActionResult)
    case createBot(CreateBotResult)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct CreateBotInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the bot
  public var name: String = String()

  /// Username of the bot
  public var username: String = String()

  /// If not null, add the bot to this space
  public var addToSpace: Int64 {
    get {return _addToSpace ?? 0}
    set {_addToSpace = newValue}
  }
  /// Returns true if `addToSpace` has been explicitly set.
  public var hasAddToSpace: Bool {return self._addToSpace != nil}
  /// Clears the value of `addToSpace`. Subsequent reads from it will return its default value.
  public mutating func clearAddToSpace() {self._addToSpace = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _addToSpace: Int64? = nil
}

public struct CreateBotResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bot: User {
    get {return _bot ?? User()}
    set {_bot = newValue}
  }
  /// Returns true if `bot` has been explicitly set.
  public var hasBot: Bool {return self._bot != nil}
  /// Clears the value of `bot`. Subsequent reads from it will return its default value.
  public mutating func clearBot() {self._bot = nil}

  /// Token to use for the bot
  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bot: User? = nil
}

public struct GetUserSettingsInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetUserSettingsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userSettings: UserSettings {
    get {return _userSettings ?? UserSettings()}
    set {_userSettings = newValue}
  }
  /// Returns true if `userSettings` has been explicitly set.
  public var hasUserSettings: Bool {return self._userSettings != nil}
  /// Clears the value of `userSettings`. Subsequent reads from it will return its default value.
  public mutating func clearUserSettings() {self._userSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userSettings: UserSettings? = nil
}

public struct UserSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notificationSettings: NotificationSettings {
    get {return _notificationSettings ?? NotificationSettings()}
    set {_notificationSettings = newValue}
  }
  /// Returns true if `notificationSettings` has been explicitly set.
  public var hasNotificationSettings: Bool {return self._notificationSettings != nil}
  /// Clears the value of `notificationSettings`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationSettings() {self._notificationSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notificationSettings: NotificationSettings? = nil
}

public struct NotificationSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: NotificationSettings.Mode {
    get {return _mode ?? .unspecified}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  /// If true, no sound will be played for notifications
  public var silent: Bool {
    get {return _silent ?? false}
    set {_silent = newValue}
  }
  /// Returns true if `silent` has been explicitly set.
  public var hasSilent: Bool {return self._silent != nil}
  /// Clears the value of `silent`. Subsequent reads from it will return its default value.
  public mutating func clearSilent() {self._silent = nil}

  /// If true, the notification requires mentioning the user
  public var zenModeRequiresMention: Bool {
    get {return _zenModeRequiresMention ?? false}
    set {_zenModeRequiresMention = newValue}
  }
  /// Returns true if `zenModeRequiresMention` has been explicitly set.
  public var hasZenModeRequiresMention: Bool {return self._zenModeRequiresMention != nil}
  /// Clears the value of `zenModeRequiresMention`. Subsequent reads from it will return its default value.
  public mutating func clearZenModeRequiresMention() {self._zenModeRequiresMention = nil}

  /// If true, the default rules will be used
  public var zenModeUsesDefaultRules: Bool {
    get {return _zenModeUsesDefaultRules ?? false}
    set {_zenModeUsesDefaultRules = newValue}
  }
  /// Returns true if `zenModeUsesDefaultRules` has been explicitly set.
  public var hasZenModeUsesDefaultRules: Bool {return self._zenModeUsesDefaultRules != nil}
  /// Clears the value of `zenModeUsesDefaultRules`. Subsequent reads from it will return its default value.
  public mutating func clearZenModeUsesDefaultRules() {self._zenModeUsesDefaultRules = nil}

  /// Custom rules for notifications
  public var zenModeCustomRules: String {
    get {return _zenModeCustomRules ?? String()}
    set {_zenModeCustomRules = newValue}
  }
  /// Returns true if `zenModeCustomRules` has been explicitly set.
  public var hasZenModeCustomRules: Bool {return self._zenModeCustomRules != nil}
  /// Clears the value of `zenModeCustomRules`. Subsequent reads from it will return its default value.
  public mutating func clearZenModeCustomRules() {self._zenModeCustomRules = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case all // = 1
    case none // = 2
    case mentions // = 3
    case importantOnly // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .all
      case 2: self = .none
      case 3: self = .mentions
      case 4: self = .importantOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .all: return 1
      case .none: return 2
      case .mentions: return 3
      case .importantOnly: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [NotificationSettings.Mode] = [
      .unspecified,
      .all,
      .none,
      .mentions,
      .importantOnly,
    ]

  }

  public init() {}

  fileprivate var _mode: NotificationSettings.Mode? = nil
  fileprivate var _silent: Bool? = nil
  fileprivate var _zenModeRequiresMention: Bool? = nil
  fileprivate var _zenModeUsesDefaultRules: Bool? = nil
  fileprivate var _zenModeCustomRules: String? = nil
}

public struct UpdateUserSettingsInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userSettings: UserSettings {
    get {return _userSettings ?? UserSettings()}
    set {_userSettings = newValue}
  }
  /// Returns true if `userSettings` has been explicitly set.
  public var hasUserSettings: Bool {return self._userSettings != nil}
  /// Clears the value of `userSettings`. Subsequent reads from it will return its default value.
  public mutating func clearUserSettings() {self._userSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userSettings: UserSettings? = nil
}

public struct UpdateUserSettingsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SendComposeActionInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Peer - where user is typing/uploading
  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Compose action (optional, null means stop action)
  public var action: UpdateComposeAction.ComposeAction {
    get {return _action ?? .none}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
  fileprivate var _action: UpdateComposeAction.ComposeAction? = nil
}

public struct SendComposeActionResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetChatsInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetChatsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Dialogs
  public var dialogs: [Dialog] = []

  /// Chats
  public var chats: [Chat] = []

  /// Spaces referenced in the chats
  public var spaces: [Space] = []

  /// Users referenced in the chats or messages
  public var users: [User] = []

  /// Messages referenced in the chats
  public var messages: [Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TranslateMessagesInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the peer
  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// IDs of the messages to translate, these must not have gaps of more than 50
  /// messages
  public var messageIds: [Int64] = []

  /// Language code to translate to
  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct TranslateMessagesResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Translated messages
  public var translations: [MessageTranslation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct MessageTranslation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the message
  public var messageID: Int64 = 0

  /// Language code of the translation
  public var language: String = String()

  /// Translation of the message
  public var translation: String = String()

  /// Date of translation
  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetMeInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetMeResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: User {
    get {return _user ?? User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: User? = nil
}

public struct GetPeerPhotoInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var photoID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct GetPeerPhotoResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  public var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  public mutating func clearPhoto() {self._photo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _photo: Photo? = nil
}

public struct DeleteMessagesInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Int64] = []

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct DeleteMessagesResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EditMessageInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: Int64 = 0

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct EditMessageResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputMedia: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var media: InputMedia.OneOf_Media? = nil

  public var photo: InputMediaPhoto {
    get {
      if case .photo(let v)? = media {return v}
      return InputMediaPhoto()
    }
    set {media = .photo(newValue)}
  }

  public var video: InputMediaVideo {
    get {
      if case .video(let v)? = media {return v}
      return InputMediaVideo()
    }
    set {media = .video(newValue)}
  }

  public var document: InputMediaDocument {
    get {
      if case .document(let v)? = media {return v}
      return InputMediaDocument()
    }
    set {media = .document(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Media: Equatable, Sendable {
    case photo(InputMediaPhoto)
    case video(InputMediaVideo)
    case document(InputMediaDocument)

  }

  public init() {}
}

public struct InputMediaPhoto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the photo that we have uploaded
  public var photoID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputMediaVideo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the video that we have uploaded
  public var videoID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputMediaDocument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the document that we have uploaded
  public var documentID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SendMessageInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Message text or caption
  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  /// Message ID of the message being replied to
  public var replyToMsgID: Int64 {
    get {return _replyToMsgID ?? 0}
    set {_replyToMsgID = newValue}
  }
  /// Returns true if `replyToMsgID` has been explicitly set.
  public var hasReplyToMsgID: Bool {return self._replyToMsgID != nil}
  /// Clears the value of `replyToMsgID`. Subsequent reads from it will return its default value.
  public mutating func clearReplyToMsgID() {self._replyToMsgID = nil}

  /// Random ID to prevent duplicate messages
  public var randomID: Int64 {
    get {return _randomID ?? 0}
    set {_randomID = newValue}
  }
  /// Returns true if `randomID` has been explicitly set.
  public var hasRandomID: Bool {return self._randomID != nil}
  /// Clears the value of `randomID`. Subsequent reads from it will return its default value.
  public mutating func clearRandomID() {self._randomID = nil}

  /// Media to send
  public var media: InputMedia {
    get {return _media ?? InputMedia()}
    set {_media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {return self._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {self._media = nil}

  /// Date of sending (until we fix the client reordering)
  public var temporarySendDate: Int64 {
    get {return _temporarySendDate ?? 0}
    set {_temporarySendDate = newValue}
  }
  /// Returns true if `temporarySendDate` has been explicitly set.
  public var hasTemporarySendDate: Bool {return self._temporarySendDate != nil}
  /// Clears the value of `temporarySendDate`. Subsequent reads from it will return its default value.
  public mutating func clearTemporarySendDate() {self._temporarySendDate = nil}

  /// Whether the message is a sticker
  public var isSticker: Bool {
    get {return _isSticker ?? false}
    set {_isSticker = newValue}
  }
  /// Returns true if `isSticker` has been explicitly set.
  public var hasIsSticker: Bool {return self._isSticker != nil}
  /// Clears the value of `isSticker`. Subsequent reads from it will return its default value.
  public mutating func clearIsSticker() {self._isSticker = nil}

  /// Entities in the message (bold, italic, mention, etc)
  public var entities: MessageEntities {
    get {return _entities ?? MessageEntities()}
    set {_entities = newValue}
  }
  /// Returns true if `entities` has been explicitly set.
  public var hasEntities: Bool {return self._entities != nil}
  /// Clears the value of `entities`. Subsequent reads from it will return its default value.
  public mutating func clearEntities() {self._entities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
  fileprivate var _message: String? = nil
  fileprivate var _replyToMsgID: Int64? = nil
  fileprivate var _randomID: Int64? = nil
  fileprivate var _media: InputMedia? = nil
  fileprivate var _temporarySendDate: Int64? = nil
  fileprivate var _isSticker: Bool? = nil
  fileprivate var _entities: MessageEntities? = nil
}

public struct SendMessageResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updates: [Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetChatHistoryInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// ID of the message to start from
  public var offsetID: Int64 {
    get {return _offsetID ?? 0}
    set {_offsetID = newValue}
  }
  /// Returns true if `offsetID` has been explicitly set.
  public var hasOffsetID: Bool {return self._offsetID != nil}
  /// Clears the value of `offsetID`. Subsequent reads from it will return its default value.
  public mutating func clearOffsetID() {self._offsetID = nil}

  /// Number of messages to return
  public var limit: Int32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
  fileprivate var _offsetID: Int64? = nil
  fileprivate var _limit: Int32? = nil
}

public struct GetChatHistoryResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InputChatParticipant: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CreateChatInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required title
  public var title: String = String()

  /// Parent space ID
  public var spaceID: Int64 {
    get {return _spaceID ?? 0}
    set {_spaceID = newValue}
  }
  /// Returns true if `spaceID` has been explicitly set.
  public var hasSpaceID: Bool {return self._spaceID != nil}
  /// Clears the value of `spaceID`. Subsequent reads from it will return its default value.
  public mutating func clearSpaceID() {self._spaceID = nil}

  /// Optional description of the thread
  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  /// Emoji to show as the icon, can be null
  public var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {self._emoji = nil}

  /// If true, everyone in parent space can accces it
  public var isPublic: Bool = false

  /// For public threads, it must be an empty list
  public var participants: [InputChatParticipant] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _spaceID: Int64? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _emoji: String? = nil
}

public struct CreateChatResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chat: Chat {
    get {return _chat ?? Chat()}
    set {_chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return self._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {self._chat = nil}

  public var dialog: Dialog {
    get {return _dialog ?? Dialog()}
    set {_dialog = newValue}
  }
  /// Returns true if `dialog` has been explicitly set.
  public var hasDialog: Bool {return self._dialog != nil}
  /// Clears the value of `dialog`. Subsequent reads from it will return its default value.
  public mutating func clearDialog() {self._dialog = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chat: Chat? = nil
  fileprivate var _dialog: Dialog? = nil
}

public struct GetSpaceMembersInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var spaceID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetSpaceMembersResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var members: [Member] = []

  public var users: [User] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// ------------------------------
/// Updates Subsystem
public struct Update: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var update: Update.OneOf_Update? = nil

  public var newMessage: UpdateNewMessage {
    get {
      if case .newMessage(let v)? = update {return v}
      return UpdateNewMessage()
    }
    set {update = .newMessage(newValue)}
  }

  public var editMessage: UpdateEditMessage {
    get {
      if case .editMessage(let v)? = update {return v}
      return UpdateEditMessage()
    }
    set {update = .editMessage(newValue)}
  }

  public var updateMessageID: UpdateMessageId {
    get {
      if case .updateMessageID(let v)? = update {return v}
      return UpdateMessageId()
    }
    set {update = .updateMessageID(newValue)}
  }

  public var deleteMessages: UpdateDeleteMessages {
    get {
      if case .deleteMessages(let v)? = update {return v}
      return UpdateDeleteMessages()
    }
    set {update = .deleteMessages(newValue)}
  }

  public var updateComposeAction: UpdateComposeAction {
    get {
      if case .updateComposeAction(let v)? = update {return v}
      return UpdateComposeAction()
    }
    set {update = .updateComposeAction(newValue)}
  }

  public var updateUserStatus: UpdateUserStatus {
    get {
      if case .updateUserStatus(let v)? = update {return v}
      return UpdateUserStatus()
    }
    set {update = .updateUserStatus(newValue)}
  }

  public var messageAttachment: UpdateMessageAttachment {
    get {
      if case .messageAttachment(let v)? = update {return v}
      return UpdateMessageAttachment()
    }
    set {update = .messageAttachment(newValue)}
  }

  public var updateReaction: UpdateReaction {
    get {
      if case .updateReaction(let v)? = update {return v}
      return UpdateReaction()
    }
    set {update = .updateReaction(newValue)}
  }

  public var deleteReaction: UpdateDeleteReaction {
    get {
      if case .deleteReaction(let v)? = update {return v}
      return UpdateDeleteReaction()
    }
    set {update = .deleteReaction(newValue)}
  }

  public var participantAdd: UpdateChatParticipantAdd {
    get {
      if case .participantAdd(let v)? = update {return v}
      return UpdateChatParticipantAdd()
    }
    set {update = .participantAdd(newValue)}
  }

  public var participantDelete: UpdateChatParticipantDelete {
    get {
      if case .participantDelete(let v)? = update {return v}
      return UpdateChatParticipantDelete()
    }
    set {update = .participantDelete(newValue)}
  }

  public var newChat: UpdateNewChat {
    get {
      if case .newChat(let v)? = update {return v}
      return UpdateNewChat()
    }
    set {update = .newChat(newValue)}
  }

  public var deleteChat: UpdateDeleteChat {
    get {
      if case .deleteChat(let v)? = update {return v}
      return UpdateDeleteChat()
    }
    set {update = .deleteChat(newValue)}
  }

  public var spaceMemberAdd: UpdateSpaceMemberAdd {
    get {
      if case .spaceMemberAdd(let v)? = update {return v}
      return UpdateSpaceMemberAdd()
    }
    set {update = .spaceMemberAdd(newValue)}
  }

  public var spaceMemberDelete: UpdateSpaceMemberDelete {
    get {
      if case .spaceMemberDelete(let v)? = update {return v}
      return UpdateSpaceMemberDelete()
    }
    set {update = .spaceMemberDelete(newValue)}
  }

  public var joinSpace: UpdateJoinSpace {
    get {
      if case .joinSpace(let v)? = update {return v}
      return UpdateJoinSpace()
    }
    set {update = .joinSpace(newValue)}
  }

  public var updateReadMaxID: UpdateReadMaxId {
    get {
      if case .updateReadMaxID(let v)? = update {return v}
      return UpdateReadMaxId()
    }
    set {update = .updateReadMaxID(newValue)}
  }

  public var updateUserSettings: UpdateUserSettings {
    get {
      if case .updateUserSettings(let v)? = update {return v}
      return UpdateUserSettings()
    }
    set {update = .updateUserSettings(newValue)}
  }

  public var newMessageNotification: UpdateNewMessageNotification {
    get {
      if case .newMessageNotification(let v)? = update {return v}
      return UpdateNewMessageNotification()
    }
    set {update = .newMessageNotification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Update: Equatable, Sendable {
    case newMessage(UpdateNewMessage)
    case editMessage(UpdateEditMessage)
    case updateMessageID(UpdateMessageId)
    case deleteMessages(UpdateDeleteMessages)
    case updateComposeAction(UpdateComposeAction)
    case updateUserStatus(UpdateUserStatus)
    case messageAttachment(UpdateMessageAttachment)
    case updateReaction(UpdateReaction)
    case deleteReaction(UpdateDeleteReaction)
    case participantAdd(UpdateChatParticipantAdd)
    case participantDelete(UpdateChatParticipantDelete)
    case newChat(UpdateNewChat)
    case deleteChat(UpdateDeleteChat)
    case spaceMemberAdd(UpdateSpaceMemberAdd)
    case spaceMemberDelete(UpdateSpaceMemberDelete)
    case joinSpace(UpdateJoinSpace)
    case updateReadMaxID(UpdateReadMaxId)
    case updateUserSettings(UpdateUserSettings)
    case newMessageNotification(UpdateNewMessageNotification)

  }

  public init() {}
}

public struct UpdateNewMessageNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message that triggered the notification
  public var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  /// Reason for the notification
  public var reason: UpdateNewMessageNotification.Reason = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case mention // = 1
    case important // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .mention
      case 2: self = .important
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .mention: return 1
      case .important: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [UpdateNewMessageNotification.Reason] = [
      .unspecified,
      .mention,
      .important,
    ]

  }

  public init() {}

  fileprivate var _message: Message? = nil
}

public struct UpdateUserSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var settings: UserSettings {
    get {return _settings ?? UserSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {self._settings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _settings: UserSettings? = nil
}

/// Update when a new space member is added
public struct UpdateSpaceMemberAdd: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var member: Member {
    get {return _storage._member ?? Member()}
    set {_uniqueStorage()._member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return _storage._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {_uniqueStorage()._member = nil}

  public var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Update when a space member is removed
public struct UpdateSpaceMemberDelete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update when we joined a space
public struct UpdateJoinSpace: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var space: Space {
    get {return _space ?? Space()}
    set {_space = newValue}
  }
  /// Returns true if `space` has been explicitly set.
  public var hasSpace: Bool {return self._space != nil}
  /// Clears the value of `space`. Subsequent reads from it will return its default value.
  public mutating func clearSpace() {self._space = nil}

  public var member: Member {
    get {return _member ?? Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {self._member = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _space: Space? = nil
  fileprivate var _member: Member? = nil
}

/// Update when we read up to a certain message ID
public struct UpdateReadMaxId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Peer ID
  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Read max ID
  public var readMaxID: Int64 = 0

  /// Still unread count
  public var unreadCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: Peer? = nil
}

/// Update when a new chat is created either in space or a private chat
public struct UpdateNewChat: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Chat
  public var chat: Chat {
    get {return _storage._chat ?? Chat()}
    set {_uniqueStorage()._chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return _storage._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {_uniqueStorage()._chat = nil}

  /// If private chat
  public var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Update when a chat is deleted
public struct UpdateDeleteChat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Peer ID
  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: Peer? = nil
}

/// Update when a new message is created
public struct UpdateNewMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Message? = nil
}

/// Update when a message is edited
public struct UpdateEditMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: Message {
    get {return _message ?? Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: Message? = nil
}

/// Update when messages are deleted
public struct UpdateDeleteMessages: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Int64] = []

  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: Peer? = nil
}

/// Update when a message ID is updated after sending
public struct UpdateMessageId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: Int64 = 0

  public var randomID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update when a user starts or stops composing a message for typing, uploading
/// a photo, etc
public struct UpdateComposeAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User ID of the user who is composing the message
  public var userID: Int64 = 0

  /// Peer ID of the peer user is composing the message to
  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  /// Action of the user (typing, etc)
  public var action: UpdateComposeAction.ComposeAction = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ComposeAction: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case none // = 0
    case typing // = 1
    case uploadingPhoto // = 2
    case uploadingDocument // = 3
    case uploadingVideo // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .typing
      case 2: self = .uploadingPhoto
      case 3: self = .uploadingDocument
      case 4: self = .uploadingVideo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .typing: return 1
      case .uploadingPhoto: return 2
      case .uploadingDocument: return 3
      case .uploadingVideo: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [UpdateComposeAction.ComposeAction] = [
      .none,
      .typing,
      .uploadingPhoto,
      .uploadingDocument,
      .uploadingVideo,
    ]

  }

  public init() {}

  fileprivate var _peerID: Peer? = nil
}

public struct UpdateMessageAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachment: MessageAttachment {
    get {return _attachment ?? MessageAttachment()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  public var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  public mutating func clearAttachment() {self._attachment = nil}

  public var messageID: Int64 = 0

  public var peerID: Peer {
    get {return _peerID ?? Peer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachment: MessageAttachment? = nil
  fileprivate var _peerID: Peer? = nil
}

public struct UpdateReaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reaction: Reaction {
    get {return _reaction ?? Reaction()}
    set {_reaction = newValue}
  }
  /// Returns true if `reaction` has been explicitly set.
  public var hasReaction: Bool {return self._reaction != nil}
  /// Clears the value of `reaction`. Subsequent reads from it will return its default value.
  public mutating func clearReaction() {self._reaction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _reaction: Reaction? = nil
}

public struct UpdateDeleteReaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var emoji: String = String()

  public var chatID: Int64 = 0

  public var messageID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UpdateUserStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var status: UserStatus {
    get {return _status ?? UserStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: UserStatus? = nil
}

public struct ChatParticipant: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var date: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UpdateChatParticipantAdd: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var participant: ChatParticipant {
    get {return _participant ?? ChatParticipant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  public var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  public mutating func clearParticipant() {self._participant = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _participant: ChatParticipant? = nil
}

public struct UpdateChatParticipantDelete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var online: UserStatus.Status = .unknown

  public var lastOnline: LastOnline {
    get {return _lastOnline ?? LastOnline()}
    set {_lastOnline = newValue}
  }
  /// Returns true if `lastOnline` has been explicitly set.
  public var hasLastOnline: Bool {return self._lastOnline != nil}
  /// Clears the value of `lastOnline`. Subsequent reads from it will return its default value.
  public mutating func clearLastOnline() {self._lastOnline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case online // = 1
    case offline // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .online
      case 2: self = .offline
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .online: return 1
      case .offline: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [UserStatus.Status] = [
      .unknown,
      .online,
      .offline,
    ]

  }

  public init() {}

  fileprivate var _lastOnline: LastOnline? = nil
}

public struct LastOnline: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Date of the last online if exact last online is permitted by the user
  public var date: Int64 {
    get {return _date ?? 0}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: Int64? = nil
}

public struct DeleteChatInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var peerID: InputPeer {
    get {return _peerID ?? InputPeer()}
    set {_peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  public var hasPeerID: Bool {return self._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  public mutating func clearPeerID() {self._peerID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _peerID: InputPeer? = nil
}

public struct DeleteChatResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct InviteToSpaceInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the space to invite to
  public var spaceID: Int64 = 0

  /// Role of the user to invite
  public var role: Member.Role = .owner

  public var via: InviteToSpaceInput.OneOf_Via? = nil

  /// ID of the user to invite
  public var userID: Int64 {
    get {
      if case .userID(let v)? = via {return v}
      return 0
    }
    set {via = .userID(newValue)}
  }

  /// Email of the user to invite
  public var email: String {
    get {
      if case .email(let v)? = via {return v}
      return String()
    }
    set {via = .email(newValue)}
  }

  /// Phone number of the user to invite
  public var phoneNumber: String {
    get {
      if case .phoneNumber(let v)? = via {return v}
      return String()
    }
    set {via = .phoneNumber(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Via: Equatable, Sendable {
    /// ID of the user to invite
    case userID(Int64)
    /// Email of the user to invite
    case email(String)
    /// Phone number of the user to invite
    case phoneNumber(String)

  }

  public init() {}
}

public struct InviteToSpaceResult: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  public var member: Member {
    get {return _storage._member ?? Member()}
    set {_uniqueStorage()._member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  public var hasMember: Bool {return _storage._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  public mutating func clearMember() {_uniqueStorage()._member = nil}

  public var chat: Chat {
    get {return _storage._chat ?? Chat()}
    set {_uniqueStorage()._chat = newValue}
  }
  /// Returns true if `chat` has been explicitly set.
  public var hasChat: Bool {return _storage._chat != nil}
  /// Clears the value of `chat`. Subsequent reads from it will return its default value.
  public mutating func clearChat() {_uniqueStorage()._chat = nil}

  public var dialog: Dialog {
    get {return _storage._dialog ?? Dialog()}
    set {_uniqueStorage()._dialog = newValue}
  }
  /// Returns true if `dialog` has been explicitly set.
  public var hasDialog: Bool {return _storage._dialog != nil}
  /// Clears the value of `dialog`. Subsequent reads from it will return its default value.
  public mutating func clearDialog() {_uniqueStorage()._dialog = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct GetChatParticipantsInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GetChatParticipantsResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var participants: [ChatParticipant] = []

  public var users: [User] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AddChatParticipantInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AddChatParticipantResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var participant: ChatParticipant {
    get {return _participant ?? ChatParticipant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  public var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  public mutating func clearParticipant() {self._participant = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _participant: ChatParticipant? = nil
}

public struct RemoveChatParticipantInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RemoveChatParticipantResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Apple only types
public struct DraftMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var entities: MessageEntities {
    get {return _entities ?? MessageEntities()}
    set {_entities = newValue}
  }
  /// Returns true if `entities` has been explicitly set.
  public var hasEntities: Bool {return self._entities != nil}
  /// Clears the value of `entities`. Subsequent reads from it will return its default value.
  public mutating func clearEntities() {self._entities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entities: MessageEntities? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "GET_ME"),
    2: .same(proto: "SEND_MESSAGE"),
    3: .same(proto: "GET_PEER_PHOTO"),
    4: .same(proto: "DELETE_MESSAGES"),
    5: .same(proto: "GET_CHAT_HISTORY"),
    6: .same(proto: "ADD_REACTION"),
    7: .same(proto: "DELETE_REACTION"),
    8: .same(proto: "EDIT_MESSAGE"),
    9: .same(proto: "CREATE_CHAT"),
    10: .same(proto: "GET_SPACE_MEMBERS"),
    11: .same(proto: "DELETE_CHAT"),
    12: .same(proto: "INVITE_TO_SPACE"),
    13: .same(proto: "GET_CHAT_PARTICIPANTS"),
    14: .same(proto: "ADD_CHAT_PARTICIPANT"),
    15: .same(proto: "REMOVE_CHAT_PARTICIPANT"),
    16: .same(proto: "TRANSLATE_MESSAGES"),
    17: .same(proto: "GET_CHATS"),
    18: .same(proto: "UPDATE_USER_SETTINGS"),
    19: .same(proto: "GET_USER_SETTINGS"),
    20: .same(proto: "SEND_COMPOSE_ACTION"),
    21: .same(proto: "CREATE_BOT"),
  ]
}

extension ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "seq"),
    4: .standard(proto: "connection_init"),
    5: .standard(proto: "rpc_call"),
    6: .same(proto: "ack"),
    7: .same(proto: "ping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 4: try {
        var v: ConnectionInit?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .connectionInit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .connectionInit(v)
        }
      }()
      case 5: try {
        var v: RpcCall?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .rpcCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .rpcCall(v)
        }
      }()
      case 6: try {
        var v: Ack?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .ack(v)
        }
      }()
      case 7: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 2)
    }
    switch self.body {
    case .connectionInit?: try {
      guard case .connectionInit(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rpcCall?: try {
      guard case .rpcCall(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientMessage, rhs: ClientMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.seq != rhs.seq {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectionInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConnectionInit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "build_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._buildNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try { if let v = self._buildNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConnectionInit, rhs: ConnectionInit) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs._buildNumber != rhs._buildNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServerProtocolMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ServerProtocolMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    4: .standard(proto: "connection_open"),
    5: .standard(proto: "rpc_result"),
    6: .standard(proto: "rpc_error"),
    7: .same(proto: "message"),
    8: .same(proto: "ack"),
    9: .same(proto: "pong"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 4: try {
        var v: ConnectionOpen?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .connectionOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .connectionOpen(v)
        }
      }()
      case 5: try {
        var v: RpcResult?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .rpcResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .rpcResult(v)
        }
      }()
      case 6: try {
        var v: RpcError?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .rpcError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .rpcError(v)
        }
      }()
      case 7: try {
        var v: ServerMessage?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .message(v)
        }
      }()
      case 8: try {
        var v: Ack?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .ack(v)
        }
      }()
      case 9: try {
        var v: Pong?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pong(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    switch self.body {
    case .connectionOpen?: try {
      guard case .connectionOpen(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rpcResult?: try {
      guard case .rpcResult(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .rpcError?: try {
      guard case .rpcError(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .message?: try {
      guard case .message(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerProtocolMessage, rhs: ServerProtocolMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ServerMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: UpdatesPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerMessage, rhs: ServerMessage) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdatesPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdatesPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdatesPayload, rhs: UpdatesPayload) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.msgID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ack, rhs: Ack) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectionOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ConnectionOpen"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ConnectionOpen, rhs: ConnectionOpen) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Ping"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ping, rhs: Ping) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Pong"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Pong, rhs: Pong) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "self"),
    3: .same(proto: "chat"),
    4: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: InputPeerSelf?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .self_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .self_p(v)
        }
      }()
      case 3: try {
        var v: InputPeerChat?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chat(v)
        }
      }()
      case 4: try {
        var v: InputPeerUser?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .user(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .self_p?: try {
      guard case .self_p(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .chat?: try {
      guard case .chat(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .user?: try {
      guard case .user(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeer, rhs: InputPeer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeerSelf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeerSelf"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeerSelf, rhs: InputPeerSelf) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeerChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeerChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeerChat, rhs: InputPeerChat) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputPeerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputPeerUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputPeerUser, rhs: InputPeerUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Peer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "chat"),
    3: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: PeerChat?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chat(v)
        }
      }()
      case 3: try {
        var v: PeerUser?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .user(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .chat?: try {
      guard case .chat(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .user?: try {
      guard case .user(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Peer, rhs: Peer) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeerChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeerChat, rhs: PeerChat) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PeerUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PeerUser, rhs: PeerUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "User"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "first_name"),
    3: .standard(proto: "last_name"),
    4: .same(proto: "username"),
    5: .standard(proto: "phone_number"),
    6: .same(proto: "email"),
    7: .same(proto: "min"),
    8: .same(proto: "status"),
    9: .standard(proto: "profile_photo"),
    11: .standard(proto: "pending_setup"),
    12: .standard(proto: "time_zone"),
    13: .same(proto: "bot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._firstName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._lastName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._phoneNumber) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._email) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._min) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._profilePhoto) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._pendingSetup) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._timeZone) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._bot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._firstName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._phoneNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._email {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._min {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._profilePhoto {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._pendingSetup {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._timeZone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._bot {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._firstName != rhs._firstName {return false}
    if lhs._lastName != rhs._lastName {return false}
    if lhs._username != rhs._username {return false}
    if lhs._phoneNumber != rhs._phoneNumber {return false}
    if lhs._email != rhs._email {return false}
    if lhs._min != rhs._min {return false}
    if lhs._status != rhs._status {return false}
    if lhs._profilePhoto != rhs._profilePhoto {return false}
    if lhs._pendingSetup != rhs._pendingSetup {return false}
    if lhs._timeZone != rhs._timeZone {return false}
    if lhs._bot != rhs._bot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserProfilePhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserProfilePhoto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
    2: .standard(proto: "stripped_thumb"),
    3: .standard(proto: "cdn_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._photoID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._strippedThumb) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._photoID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._strippedThumb {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserProfilePhoto, rhs: UserProfilePhoto) -> Bool {
    if lhs._photoID != rhs._photoID {return false}
    if lhs._strippedThumb != rhs._strippedThumb {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Dialog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Dialog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peer"),
    2: .standard(proto: "space_id"),
    3: .same(proto: "archived"),
    4: .same(proto: "pinned"),
    5: .standard(proto: "read_max_id"),
    6: .standard(proto: "unread_count"),
    7: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peer) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._spaceID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._archived) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._pinned) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._readMaxID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._unreadCount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spaceID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._archived {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pinned {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._readMaxID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._unreadCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._chatID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Dialog, rhs: Dialog) -> Bool {
    if lhs._peer != rhs._peer {return false}
    if lhs._spaceID != rhs._spaceID {return false}
    if lhs._archived != rhs._archived {return false}
    if lhs._pinned != rhs._pinned {return false}
    if lhs._readMaxID != rhs._readMaxID {return false}
    if lhs._unreadCount != rhs._unreadCount {return false}
    if lhs._chatID != rhs._chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Chat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .standard(proto: "space_id"),
    4: .same(proto: "description"),
    5: .same(proto: "emoji"),
    6: .standard(proto: "is_public"),
    7: .standard(proto: "last_msg_id"),
    8: .standard(proto: "peer_id"),
    9: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._spaceID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isPublic) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._lastMsgID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try { if let v = self._spaceID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isPublic {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastMsgID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Chat, rhs: Chat) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs._spaceID != rhs._spaceID {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs._isPublic != rhs._isPublic {return false}
    if lhs._lastMsgID != rhs._lastMsgID {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "from_id"),
    3: .standard(proto: "peer_id"),
    4: .standard(proto: "chat_id"),
    5: .same(proto: "message"),
    6: .same(proto: "out"),
    7: .same(proto: "date"),
    8: .same(proto: "mentioned"),
    9: .standard(proto: "reply_to_msg_id"),
    10: .same(proto: "media"),
    11: .standard(proto: "edit_date"),
    12: .standard(proto: "grouped_id"),
    13: .same(proto: "attachments"),
    14: .same(proto: "reactions"),
    15: .standard(proto: "is_sticker"),
    16: .same(proto: "entities"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _fromID: Int64 = 0
    var _peerID: Peer? = nil
    var _chatID: Int64 = 0
    var _message: String? = nil
    var _out: Bool = false
    var _date: Int64 = 0
    var _mentioned: Bool? = nil
    var _replyToMsgID: Int64? = nil
    var _media: MessageMedia? = nil
    var _editDate: Int64? = nil
    var _groupedID: Int64? = nil
    var _attachments: MessageAttachments? = nil
    var _reactions: MessageReactions? = nil
    var _isSticker: Bool? = nil
    var _entities: MessageEntities? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fromID = source._fromID
      _peerID = source._peerID
      _chatID = source._chatID
      _message = source._message
      _out = source._out
      _date = source._date
      _mentioned = source._mentioned
      _replyToMsgID = source._replyToMsgID
      _media = source._media
      _editDate = source._editDate
      _groupedID = source._groupedID
      _attachments = source._attachments
      _reactions = source._reactions
      _isSticker = source._isSticker
      _entities = source._entities
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._fromID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._peerID) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._chatID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._out) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._date) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._mentioned) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._replyToMsgID) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._media) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._editDate) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._groupedID) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._attachments) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._reactions) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isSticker) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._entities) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._fromID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fromID, fieldNumber: 2)
      }
      try { if let v = _storage._peerID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._chatID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._chatID, fieldNumber: 4)
      }
      try { if let v = _storage._message {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      if _storage._out != false {
        try visitor.visitSingularBoolField(value: _storage._out, fieldNumber: 6)
      }
      if _storage._date != 0 {
        try visitor.visitSingularInt64Field(value: _storage._date, fieldNumber: 7)
      }
      try { if let v = _storage._mentioned {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._replyToMsgID {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._media {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._editDate {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._groupedID {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._attachments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._reactions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._isSticker {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._entities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Message, rhs: Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fromID != rhs_storage._fromID {return false}
        if _storage._peerID != rhs_storage._peerID {return false}
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._out != rhs_storage._out {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._mentioned != rhs_storage._mentioned {return false}
        if _storage._replyToMsgID != rhs_storage._replyToMsgID {return false}
        if _storage._media != rhs_storage._media {return false}
        if _storage._editDate != rhs_storage._editDate {return false}
        if _storage._groupedID != rhs_storage._groupedID {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._reactions != rhs_storage._reactions {return false}
        if _storage._isSticker != rhs_storage._isSticker {return false}
        if _storage._entities != rhs_storage._entities {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEntities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageEntities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEntities, rhs: MessageEntities) -> Bool {
    if lhs.entities != rhs.entities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "offset"),
    3: .same(proto: "length"),
    4: .same(proto: "mention"),
    5: .standard(proto: "text_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.length) }()
      case 4: try {
        var v: MessageEntity.MessageEntityMention?
        var hadOneofValue = false
        if let current = self.entity {
          hadOneofValue = true
          if case .mention(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entity = .mention(v)
        }
      }()
      case 5: try {
        var v: MessageEntity.MessageEntityTextUrl?
        var hadOneofValue = false
        if let current = self.entity {
          hadOneofValue = true
          if case .textURL(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.entity = .textURL(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularInt64Field(value: self.length, fieldNumber: 3)
    }
    switch self.entity {
    case .mention?: try {
      guard case .mention(let v)? = self.entity else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .textURL?: try {
      guard case .textURL(let v)? = self.entity else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEntity, rhs: MessageEntity) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.length != rhs.length {return false}
    if lhs.entity != rhs.entity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEntity.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "TYPE_MENTION"),
    2: .same(proto: "TYPE_URL"),
    3: .same(proto: "TYPE_TEXT_URL"),
    4: .same(proto: "TYPE_EMAIL"),
    5: .same(proto: "TYPE_BOLD"),
    6: .same(proto: "TYPE_ITALIC"),
    7: .same(proto: "TYPE_USERNAME_MENTION"),
    8: .same(proto: "TYPE_CODE"),
  ]
}

extension MessageEntity.MessageEntityMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MessageEntity.protoMessageName + ".MessageEntityMention"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEntity.MessageEntityMention, rhs: MessageEntity.MessageEntityMention) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageEntity.MessageEntityTextUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = MessageEntity.protoMessageName + ".MessageEntityTextUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageEntity.MessageEntityTextUrl, rhs: MessageEntity.MessageEntityTextUrl) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageReactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageReactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageReactions, rhs: MessageReactions) -> Bool {
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Reaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "chat_id"),
    5: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 4)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Reaction, rhs: Reaction) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "space_id"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "role"),
    5: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.spaceID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._role) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.spaceID != 0 {
      try visitor.visitSingularInt64Field(value: self.spaceID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._role {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Member, rhs: Member) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Member.Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OWNER"),
    1: .same(proto: "ADMIN"),
    2: .same(proto: "MEMBER"),
  ]
}

extension Space: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Space"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "creator"),
    4: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.creator) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.creator != false {
      try visitor.visitSingularBoolField(value: self.creator, fieldNumber: 3)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Space, rhs: Space) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.creator != rhs.creator {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddReactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddReactionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 2)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddReactionInput, rhs: AddReactionInput) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddReactionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddReactionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddReactionResult, rhs: AddReactionResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteReactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteReactionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "peer_id"),
    3: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteReactionInput, rhs: DeleteReactionInput) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteReactionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteReactionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteReactionResult, rhs: DeleteReactionResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageAttachments"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageAttachments, rhs: MessageAttachments) -> Bool {
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "id"),
    2: .standard(proto: "external_task"),
    3: .standard(proto: "url_preview"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: MessageAttachmentExternalTask?
        var hadOneofValue = false
        if let current = self.attachment {
          hadOneofValue = true
          if case .externalTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attachment = .externalTask(v)
        }
      }()
      case 3: try {
        var v: UrlPreview?
        var hadOneofValue = false
        if let current = self.attachment {
          hadOneofValue = true
          if case .urlPreview(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attachment = .urlPreview(v)
        }
      }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.attachment {
    case .externalTask?: try {
      guard case .externalTask(let v)? = self.attachment else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .urlPreview?: try {
      guard case .urlPreview(let v)? = self.attachment else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageAttachment, rhs: MessageAttachment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.attachment != rhs.attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UrlPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UrlPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "url"),
    3: .standard(proto: "site_name"),
    4: .same(proto: "title"),
    5: .same(proto: "description"),
    6: .same(proto: "photo"),
    7: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._siteName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._siteName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._duration {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UrlPreview, rhs: UrlPreview) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._url != rhs._url {return false}
    if lhs._siteName != rhs._siteName {return false}
    if lhs._title != rhs._title {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._photo != rhs._photo {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachmentExternalTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageAttachmentExternalTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "task_id"),
    3: .same(proto: "application"),
    4: .same(proto: "title"),
    5: .same(proto: "status"),
    6: .standard(proto: "assigned_user_id"),
    7: .same(proto: "url"),
    8: .same(proto: "number"),
    9: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.assignedUserID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.taskID.isEmpty {
      try visitor.visitSingularStringField(value: self.taskID, fieldNumber: 2)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.assignedUserID != 0 {
      try visitor.visitSingularInt64Field(value: self.assignedUserID, fieldNumber: 6)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 7)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 8)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageAttachmentExternalTask, rhs: MessageAttachmentExternalTask) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.taskID != rhs.taskID {return false}
    if lhs.application != rhs.application {return false}
    if lhs.title != rhs.title {return false}
    if lhs.status != rhs.status {return false}
    if lhs.assignedUserID != rhs.assignedUserID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.number != rhs.number {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageAttachmentExternalTask.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "STATUS_BACKLOG"),
    2: .same(proto: "STATUS_TODO"),
    3: .same(proto: "STATUS_IN_PROGRESS"),
    4: .same(proto: "STATUS_DONE"),
    5: .same(proto: "STATUS_CANCELLED"),
  ]
}

extension MessageMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
    2: .same(proto: "video"),
    3: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MessagePhoto?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .photo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .photo(v)
        }
      }()
      case 2: try {
        var v: MessageVideo?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .video(v)
        }
      }()
      case 3: try {
        var v: MessageDocument?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .document(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.media {
    case .photo?: try {
      guard case .photo(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .video?: try {
      guard case .video(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .document?: try {
      guard case .document(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageMedia, rhs: MessageMedia) -> Bool {
    if lhs.media != rhs.media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessagePhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessagePhoto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessagePhoto, rhs: MessagePhoto) -> Bool {
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "video"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._video) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._video {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageVideo, rhs: MessageVideo) -> Bool {
    if lhs._video != rhs._video {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageDocument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageDocument, rhs: MessageDocument) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Video: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Video"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "w"),
    4: .same(proto: "h"),
    5: .same(proto: "duration"),
    6: .same(proto: "size"),
    7: .same(proto: "photo"),
    8: .standard(proto: "cdn_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.w) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.h) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    if self.w != 0 {
      try visitor.visitSingularInt32Field(value: self.w, fieldNumber: 3)
    }
    if self.h != 0 {
      try visitor.visitSingularInt32Field(value: self.h, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 6)
    }
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Video, rhs: Video) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.date != rhs.date {return false}
    if lhs.w != rhs.w {return false}
    if lhs.h != rhs.h {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.size != rhs.size {return false}
    if lhs._photo != rhs._photo {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Document"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "mime_type"),
    4: .same(proto: "size"),
    5: .standard(proto: "cdn_url"),
    6: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Document, rhs: Document) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.size != rhs.size {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Photo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Photo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "date"),
    3: .same(proto: "sizes"),
    4: .same(proto: "format"),
    100: .standard(proto: "file_unique_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sizes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self._fileUniqueID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    if !self.sizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sizes, fieldNumber: 3)
    }
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    try { if let v = self._fileUniqueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Photo, rhs: Photo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.date != rhs.date {return false}
    if lhs.sizes != rhs.sizes {return false}
    if lhs.format != rhs.format {return false}
    if lhs._fileUniqueID != rhs._fileUniqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Photo.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORMAT_UNSPECIFIED"),
    1: .same(proto: "FORMAT_JPEG"),
    2: .same(proto: "FORMAT_PNG"),
  ]
}

extension PhotoSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PhotoSize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "w"),
    3: .same(proto: "h"),
    4: .same(proto: "size"),
    5: .same(proto: "bytes"),
    6: .standard(proto: "cdn_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.w) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.h) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._bytes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._cdnURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.w != 0 {
      try visitor.visitSingularInt32Field(value: self.w, fieldNumber: 2)
    }
    if self.h != 0 {
      try visitor.visitSingularInt32Field(value: self.h, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 4)
    }
    try { if let v = self._bytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cdnURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PhotoSize, rhs: PhotoSize) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.w != rhs.w {return false}
    if lhs.h != rhs.h {return false}
    if lhs.size != rhs.size {return false}
    if lhs._bytes != rhs._bytes {return false}
    if lhs._cdnURL != rhs._cdnURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "req_msg_id"),
    2: .standard(proto: "error_code"),
    3: .same(proto: "message"),
    4: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.reqMsgID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reqMsgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.reqMsgID, fieldNumber: 1)
    }
    if self.errorCode != .unknown {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 3)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcError, rhs: RpcError) -> Bool {
    if lhs.reqMsgID != rhs.reqMsgID {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.message != rhs.message {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcError.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BAD_REQUEST"),
    2: .same(proto: "UNAUTHENTICATED"),
    3: .same(proto: "RATE_LIMIT"),
    4: .same(proto: "INTERNAL_ERROR"),
    5: .same(proto: "PEER_ID_INVALID"),
    6: .same(proto: "MESSAGE_ID_INVALID"),
    7: .same(proto: "USER_ID_INVALID"),
    8: .same(proto: "USER_ALREADY_MEMBER"),
    9: .same(proto: "SPACE_ID_INVALID"),
    10: .same(proto: "CHAT_ID_INVALID"),
    11: .same(proto: "EMAIL_INVALID"),
    12: .same(proto: "PHONE_NUMBER_INVALID"),
    13: .same(proto: "SPACE_ADMIN_REQUIRED"),
    14: .same(proto: "SPACE_OWNER_REQUIRED"),
  ]
}

extension RpcCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "getMe"),
    3: .same(proto: "getPeerPhoto"),
    4: .same(proto: "deleteMessages"),
    5: .same(proto: "sendMessage"),
    6: .same(proto: "getChatHistory"),
    7: .same(proto: "addReaction"),
    8: .same(proto: "deleteReaction"),
    9: .same(proto: "editMessage"),
    10: .same(proto: "createChat"),
    11: .same(proto: "getSpaceMembers"),
    12: .same(proto: "deleteChat"),
    13: .same(proto: "inviteToSpace"),
    14: .same(proto: "getChatParticipants"),
    15: .same(proto: "addChatParticipant"),
    16: .same(proto: "removeChatParticipant"),
    17: .same(proto: "translateMessages"),
    18: .same(proto: "getChats"),
    19: .same(proto: "updateUserSettings"),
    20: .same(proto: "getUserSettings"),
    21: .same(proto: "sendComposeAction"),
    22: .same(proto: "createBot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try {
        var v: GetMeInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getMe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getMe(v)
        }
      }()
      case 3: try {
        var v: GetPeerPhotoInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getPeerPhoto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getPeerPhoto(v)
        }
      }()
      case 4: try {
        var v: DeleteMessagesInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .deleteMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .deleteMessages(v)
        }
      }()
      case 5: try {
        var v: SendMessageInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .sendMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .sendMessage(v)
        }
      }()
      case 6: try {
        var v: GetChatHistoryInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getChatHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getChatHistory(v)
        }
      }()
      case 7: try {
        var v: AddReactionInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .addReaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .addReaction(v)
        }
      }()
      case 8: try {
        var v: DeleteReactionInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .deleteReaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .deleteReaction(v)
        }
      }()
      case 9: try {
        var v: EditMessageInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .editMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .editMessage(v)
        }
      }()
      case 10: try {
        var v: CreateChatInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .createChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .createChat(v)
        }
      }()
      case 11: try {
        var v: GetSpaceMembersInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getSpaceMembers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getSpaceMembers(v)
        }
      }()
      case 12: try {
        var v: DeleteChatInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .deleteChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .deleteChat(v)
        }
      }()
      case 13: try {
        var v: InviteToSpaceInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .inviteToSpace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .inviteToSpace(v)
        }
      }()
      case 14: try {
        var v: GetChatParticipantsInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getChatParticipants(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getChatParticipants(v)
        }
      }()
      case 15: try {
        var v: AddChatParticipantInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .addChatParticipant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .addChatParticipant(v)
        }
      }()
      case 16: try {
        var v: RemoveChatParticipantInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .removeChatParticipant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .removeChatParticipant(v)
        }
      }()
      case 17: try {
        var v: TranslateMessagesInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .translateMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .translateMessages(v)
        }
      }()
      case 18: try {
        var v: GetChatsInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getChats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getChats(v)
        }
      }()
      case 19: try {
        var v: UpdateUserSettingsInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .updateUserSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .updateUserSettings(v)
        }
      }()
      case 20: try {
        var v: GetUserSettingsInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .getUserSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .getUserSettings(v)
        }
      }()
      case 21: try {
        var v: SendComposeActionInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .sendComposeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .sendComposeAction(v)
        }
      }()
      case 22: try {
        var v: CreateBotInput?
        var hadOneofValue = false
        if let current = self.input {
          hadOneofValue = true
          if case .createBot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.input = .createBot(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.method != .unspecified {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    switch self.input {
    case .getMe?: try {
      guard case .getMe(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getPeerPhoto?: try {
      guard case .getPeerPhoto(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteMessages?: try {
      guard case .deleteMessages(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sendMessage?: try {
      guard case .sendMessage(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .getChatHistory?: try {
      guard case .getChatHistory(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .addReaction?: try {
      guard case .addReaction(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteReaction?: try {
      guard case .deleteReaction(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .editMessage?: try {
      guard case .editMessage(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .createChat?: try {
      guard case .createChat(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .getSpaceMembers?: try {
      guard case .getSpaceMembers(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .deleteChat?: try {
      guard case .deleteChat(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .inviteToSpace?: try {
      guard case .inviteToSpace(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .getChatParticipants?: try {
      guard case .getChatParticipants(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .addChatParticipant?: try {
      guard case .addChatParticipant(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .removeChatParticipant?: try {
      guard case .removeChatParticipant(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .translateMessages?: try {
      guard case .translateMessages(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .getChats?: try {
      guard case .getChats(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .updateUserSettings?: try {
      guard case .updateUserSettings(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .getUserSettings?: try {
      guard case .getUserSettings(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .sendComposeAction?: try {
      guard case .sendComposeAction(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .createBot?: try {
      guard case .createBot(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcCall, rhs: RpcCall) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RpcResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RpcResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "req_msg_id"),
    2: .same(proto: "getMe"),
    3: .same(proto: "getPeerPhoto"),
    4: .same(proto: "deleteMessages"),
    5: .same(proto: "sendMessage"),
    6: .same(proto: "getChatHistory"),
    7: .same(proto: "addReaction"),
    8: .same(proto: "deleteReaction"),
    9: .same(proto: "editMessage"),
    10: .same(proto: "createChat"),
    11: .same(proto: "getSpaceMembers"),
    12: .same(proto: "deleteChat"),
    13: .same(proto: "inviteToSpace"),
    14: .same(proto: "getChatParticipants"),
    15: .same(proto: "addChatParticipant"),
    16: .same(proto: "removeChatParticipant"),
    17: .same(proto: "translateMessages"),
    18: .same(proto: "getChats"),
    19: .same(proto: "updateUserSettings"),
    20: .same(proto: "getUserSettings"),
    21: .same(proto: "sendComposeAction"),
    22: .same(proto: "createBot"),
  ]

  fileprivate class _StorageClass {
    var _reqMsgID: UInt64 = 0
    var _result: RpcResult.OneOf_Result?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _reqMsgID = source._reqMsgID
      _result = source._result
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._reqMsgID) }()
        case 2: try {
          var v: GetMeResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getMe(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getMe(v)
          }
        }()
        case 3: try {
          var v: GetPeerPhotoResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getPeerPhoto(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getPeerPhoto(v)
          }
        }()
        case 4: try {
          var v: DeleteMessagesResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .deleteMessages(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .deleteMessages(v)
          }
        }()
        case 5: try {
          var v: SendMessageResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .sendMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .sendMessage(v)
          }
        }()
        case 6: try {
          var v: GetChatHistoryResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getChatHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getChatHistory(v)
          }
        }()
        case 7: try {
          var v: AddReactionResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .addReaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .addReaction(v)
          }
        }()
        case 8: try {
          var v: DeleteReactionResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .deleteReaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .deleteReaction(v)
          }
        }()
        case 9: try {
          var v: EditMessageResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .editMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .editMessage(v)
          }
        }()
        case 10: try {
          var v: CreateChatResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .createChat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .createChat(v)
          }
        }()
        case 11: try {
          var v: GetSpaceMembersResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getSpaceMembers(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getSpaceMembers(v)
          }
        }()
        case 12: try {
          var v: DeleteChatResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .deleteChat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .deleteChat(v)
          }
        }()
        case 13: try {
          var v: InviteToSpaceResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .inviteToSpace(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .inviteToSpace(v)
          }
        }()
        case 14: try {
          var v: GetChatParticipantsResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getChatParticipants(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getChatParticipants(v)
          }
        }()
        case 15: try {
          var v: AddChatParticipantResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .addChatParticipant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .addChatParticipant(v)
          }
        }()
        case 16: try {
          var v: RemoveChatParticipantResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .removeChatParticipant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .removeChatParticipant(v)
          }
        }()
        case 17: try {
          var v: TranslateMessagesResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .translateMessages(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .translateMessages(v)
          }
        }()
        case 18: try {
          var v: GetChatsResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getChats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getChats(v)
          }
        }()
        case 19: try {
          var v: UpdateUserSettingsResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .updateUserSettings(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .updateUserSettings(v)
          }
        }()
        case 20: try {
          var v: GetUserSettingsResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .getUserSettings(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .getUserSettings(v)
          }
        }()
        case 21: try {
          var v: SendComposeActionResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .sendComposeAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .sendComposeAction(v)
          }
        }()
        case 22: try {
          var v: CreateBotResult?
          var hadOneofValue = false
          if let current = _storage._result {
            hadOneofValue = true
            if case .createBot(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._result = .createBot(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._reqMsgID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._reqMsgID, fieldNumber: 1)
      }
      switch _storage._result {
      case .getMe?: try {
        guard case .getMe(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .getPeerPhoto?: try {
        guard case .getPeerPhoto(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .deleteMessages?: try {
        guard case .deleteMessages(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .sendMessage?: try {
        guard case .sendMessage(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .getChatHistory?: try {
        guard case .getChatHistory(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .addReaction?: try {
        guard case .addReaction(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .deleteReaction?: try {
        guard case .deleteReaction(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .editMessage?: try {
        guard case .editMessage(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .createChat?: try {
        guard case .createChat(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .getSpaceMembers?: try {
        guard case .getSpaceMembers(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .deleteChat?: try {
        guard case .deleteChat(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .inviteToSpace?: try {
        guard case .inviteToSpace(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .getChatParticipants?: try {
        guard case .getChatParticipants(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .addChatParticipant?: try {
        guard case .addChatParticipant(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .removeChatParticipant?: try {
        guard case .removeChatParticipant(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .translateMessages?: try {
        guard case .translateMessages(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .getChats?: try {
        guard case .getChats(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .updateUserSettings?: try {
        guard case .updateUserSettings(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .getUserSettings?: try {
        guard case .getUserSettings(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .sendComposeAction?: try {
        guard case .sendComposeAction(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .createBot?: try {
        guard case .createBot(let v)? = _storage._result else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RpcResult, rhs: RpcResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._reqMsgID != rhs_storage._reqMsgID {return false}
        if _storage._result != rhs_storage._result {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateBotInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CreateBotInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "username"),
    3: .standard(proto: "add_to_space"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._addToSpace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try { if let v = self._addToSpace {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CreateBotInput, rhs: CreateBotInput) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.username != rhs.username {return false}
    if lhs._addToSpace != rhs._addToSpace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateBotResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CreateBotResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bot"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bot) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CreateBotResult, rhs: CreateBotResult) -> Bool {
    if lhs._bot != rhs._bot {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetUserSettingsInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetUserSettingsInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetUserSettingsInput, rhs: GetUserSettingsInput) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetUserSettingsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetUserSettingsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetUserSettingsResult, rhs: GetUserSettingsResult) -> Bool {
    if lhs._userSettings != rhs._userSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._notificationSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserSettings, rhs: UserSettings) -> Bool {
    if lhs._notificationSettings != rhs._notificationSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NotificationSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "silent"),
    3: .standard(proto: "zen_mode_requires_mention"),
    4: .standard(proto: "zen_mode_uses_default_rules"),
    5: .standard(proto: "zen_mode_custom_rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._silent) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._zenModeRequiresMention) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._zenModeUsesDefaultRules) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._zenModeCustomRules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._silent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._zenModeRequiresMention {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._zenModeUsesDefaultRules {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._zenModeCustomRules {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NotificationSettings, rhs: NotificationSettings) -> Bool {
    if lhs._mode != rhs._mode {return false}
    if lhs._silent != rhs._silent {return false}
    if lhs._zenModeRequiresMention != rhs._zenModeRequiresMention {return false}
    if lhs._zenModeUsesDefaultRules != rhs._zenModeUsesDefaultRules {return false}
    if lhs._zenModeCustomRules != rhs._zenModeCustomRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NotificationSettings.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_UNSPECIFIED"),
    1: .same(proto: "MODE_ALL"),
    2: .same(proto: "MODE_NONE"),
    3: .same(proto: "MODE_MENTIONS"),
    4: .same(proto: "MODE_IMPORTANT_ONLY"),
  ]
}

extension UpdateUserSettingsInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserSettingsInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateUserSettingsInput, rhs: UpdateUserSettingsInput) -> Bool {
    if lhs._userSettings != rhs._userSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateUserSettingsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserSettingsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateUserSettingsResult, rhs: UpdateUserSettingsResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendComposeActionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendComposeActionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendComposeActionInput, rhs: SendComposeActionInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendComposeActionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendComposeActionResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendComposeActionResult, rhs: SendComposeActionResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatsInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatsInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatsInput, rhs: GetChatsInput) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dialogs"),
    2: .same(proto: "chats"),
    3: .same(proto: "spaces"),
    4: .same(proto: "users"),
    5: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dialogs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chats) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.spaces) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dialogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dialogs, fieldNumber: 1)
    }
    if !self.chats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chats, fieldNumber: 2)
    }
    if !self.spaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spaces, fieldNumber: 3)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 4)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatsResult, rhs: GetChatsResult) -> Bool {
    if lhs.dialogs != rhs.dialogs {return false}
    if lhs.chats != rhs.chats {return false}
    if lhs.spaces != rhs.spaces {return false}
    if lhs.users != rhs.users {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TranslateMessagesInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TranslateMessagesInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "message_ids"),
    4: .same(proto: "language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.messageIds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.messageIds, fieldNumber: 2)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TranslateMessagesInput, rhs: TranslateMessagesInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TranslateMessagesResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "TranslateMessagesResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "translations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.translations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.translations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TranslateMessagesResult, rhs: TranslateMessagesResult) -> Bool {
    if lhs.translations != rhs.translations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageTranslation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageTranslation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "language"),
    3: .same(proto: "translation"),
    4: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.translation) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    if !self.translation.isEmpty {
      try visitor.visitSingularStringField(value: self.translation, fieldNumber: 3)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MessageTranslation, rhs: MessageTranslation) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.language != rhs.language {return false}
    if lhs.translation != rhs.translation {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetMeInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMeInput, rhs: GetMeInput) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetMeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetMeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetMeResult, rhs: GetMeResult) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPeerPhotoInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetPeerPhotoInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.photoID != 0 {
      try visitor.visitSingularInt64Field(value: self.photoID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetPeerPhotoInput, rhs: GetPeerPhotoInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPeerPhotoResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetPeerPhotoResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetPeerPhotoResult, rhs: GetPeerPhotoResult) -> Bool {
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteMessagesInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteMessagesInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
    2: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.messageIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.messageIds, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteMessagesInput, rhs: DeleteMessagesInput) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteMessagesResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteMessagesResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteMessagesResult, rhs: DeleteMessagesResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EditMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "peer_id"),
    3: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditMessageInput, rhs: EditMessageInput) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EditMessageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "EditMessageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EditMessageResult, rhs: EditMessageResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
    2: .same(proto: "video"),
    3: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InputMediaPhoto?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .photo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .photo(v)
        }
      }()
      case 2: try {
        var v: InputMediaVideo?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .video(v)
        }
      }()
      case 3: try {
        var v: InputMediaDocument?
        var hadOneofValue = false
        if let current = self.media {
          hadOneofValue = true
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.media = .document(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.media {
    case .photo?: try {
      guard case .photo(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .video?: try {
      guard case .video(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .document?: try {
      guard case .document(let v)? = self.media else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMedia, rhs: InputMedia) -> Bool {
    if lhs.media != rhs.media {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMediaPhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMediaPhoto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "photo_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.photoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.photoID != 0 {
      try visitor.visitSingularInt64Field(value: self.photoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMediaPhoto, rhs: InputMediaPhoto) -> Bool {
    if lhs.photoID != rhs.photoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMediaVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMediaVideo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "video_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.videoID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.videoID != 0 {
      try visitor.visitSingularInt64Field(value: self.videoID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMediaVideo, rhs: InputMediaVideo) -> Bool {
    if lhs.videoID != rhs.videoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputMediaDocument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputMediaDocument"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.documentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.documentID != 0 {
      try visitor.visitSingularInt64Field(value: self.documentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputMediaDocument, rhs: InputMediaDocument) -> Bool {
    if lhs.documentID != rhs.documentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendMessageInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .same(proto: "message"),
    3: .standard(proto: "reply_to_msg_id"),
    4: .standard(proto: "random_id"),
    5: .same(proto: "media"),
    1000: .standard(proto: "temporary_send_date"),
    6: .standard(proto: "is_sticker"),
    7: .same(proto: "entities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._replyToMsgID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._randomID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._media) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isSticker) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._entities) }()
      case 1000: try { try decoder.decodeSingularInt64Field(value: &self._temporarySendDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._replyToMsgID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._randomID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._media {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._isSticker {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._entities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._temporarySendDate {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1000)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendMessageInput, rhs: SendMessageInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._message != rhs._message {return false}
    if lhs._replyToMsgID != rhs._replyToMsgID {return false}
    if lhs._randomID != rhs._randomID {return false}
    if lhs._media != rhs._media {return false}
    if lhs._temporarySendDate != rhs._temporarySendDate {return false}
    if lhs._isSticker != rhs._isSticker {return false}
    if lhs._entities != rhs._entities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SendMessageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SendMessageResult, rhs: SendMessageResult) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatHistoryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatHistoryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "offset_id"),
    3: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._offsetID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offsetID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatHistoryInput, rhs: GetChatHistoryInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._offsetID != rhs._offsetID {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatHistoryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatHistoryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatHistoryResult, rhs: GetChatHistoryResult) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InputChatParticipant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InputChatParticipant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InputChatParticipant, rhs: InputChatParticipant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateChatInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CreateChatInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "space_id"),
    3: .same(proto: "description"),
    4: .same(proto: "emoji"),
    5: .standard(proto: "is_public"),
    6: .same(proto: "participants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._spaceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isPublic) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._spaceID {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if self.isPublic != false {
      try visitor.visitSingularBoolField(value: self.isPublic, fieldNumber: 5)
    }
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CreateChatInput, rhs: CreateChatInput) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._spaceID != rhs._spaceID {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.isPublic != rhs.isPublic {return false}
    if lhs.participants != rhs.participants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateChatResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CreateChatResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chat"),
    2: .same(proto: "dialog"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chat) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dialog) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dialog {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CreateChatResult, rhs: CreateChatResult) -> Bool {
    if lhs._chat != rhs._chat {return false}
    if lhs._dialog != rhs._dialog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetSpaceMembersInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetSpaceMembersInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "space_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.spaceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.spaceID != 0 {
      try visitor.visitSingularInt64Field(value: self.spaceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetSpaceMembersInput, rhs: GetSpaceMembersInput) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetSpaceMembersResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetSpaceMembersResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
    2: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetSpaceMembersResult, rhs: GetSpaceMembersResult) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "new_message"),
    5: .standard(proto: "edit_message"),
    6: .standard(proto: "update_message_id"),
    7: .standard(proto: "delete_messages"),
    8: .standard(proto: "update_compose_action"),
    9: .standard(proto: "update_user_status"),
    10: .standard(proto: "message_attachment"),
    11: .standard(proto: "update_reaction"),
    12: .standard(proto: "delete_reaction"),
    13: .standard(proto: "participant_add"),
    14: .standard(proto: "participant_delete"),
    15: .standard(proto: "new_chat"),
    16: .standard(proto: "delete_chat"),
    17: .standard(proto: "space_member_add"),
    18: .standard(proto: "space_member_delete"),
    19: .standard(proto: "join_space"),
    20: .standard(proto: "update_read_max_id"),
    21: .standard(proto: "update_user_settings"),
    22: .standard(proto: "new_message_notification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: UpdateNewMessage?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .newMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .newMessage(v)
        }
      }()
      case 5: try {
        var v: UpdateEditMessage?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .editMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .editMessage(v)
        }
      }()
      case 6: try {
        var v: UpdateMessageId?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateMessageID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateMessageID(v)
        }
      }()
      case 7: try {
        var v: UpdateDeleteMessages?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .deleteMessages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .deleteMessages(v)
        }
      }()
      case 8: try {
        var v: UpdateComposeAction?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateComposeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateComposeAction(v)
        }
      }()
      case 9: try {
        var v: UpdateUserStatus?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateUserStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateUserStatus(v)
        }
      }()
      case 10: try {
        var v: UpdateMessageAttachment?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .messageAttachment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .messageAttachment(v)
        }
      }()
      case 11: try {
        var v: UpdateReaction?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateReaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateReaction(v)
        }
      }()
      case 12: try {
        var v: UpdateDeleteReaction?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .deleteReaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .deleteReaction(v)
        }
      }()
      case 13: try {
        var v: UpdateChatParticipantAdd?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .participantAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .participantAdd(v)
        }
      }()
      case 14: try {
        var v: UpdateChatParticipantDelete?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .participantDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .participantDelete(v)
        }
      }()
      case 15: try {
        var v: UpdateNewChat?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .newChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .newChat(v)
        }
      }()
      case 16: try {
        var v: UpdateDeleteChat?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .deleteChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .deleteChat(v)
        }
      }()
      case 17: try {
        var v: UpdateSpaceMemberAdd?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .spaceMemberAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .spaceMemberAdd(v)
        }
      }()
      case 18: try {
        var v: UpdateSpaceMemberDelete?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .spaceMemberDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .spaceMemberDelete(v)
        }
      }()
      case 19: try {
        var v: UpdateJoinSpace?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .joinSpace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .joinSpace(v)
        }
      }()
      case 20: try {
        var v: UpdateReadMaxId?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateReadMaxID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateReadMaxID(v)
        }
      }()
      case 21: try {
        var v: UpdateUserSettings?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateUserSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateUserSettings(v)
        }
      }()
      case 22: try {
        var v: UpdateNewMessageNotification?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .newMessageNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .newMessageNotification(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.update {
    case .newMessage?: try {
      guard case .newMessage(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .editMessage?: try {
      guard case .editMessage(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .updateMessageID?: try {
      guard case .updateMessageID(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deleteMessages?: try {
      guard case .deleteMessages(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .updateComposeAction?: try {
      guard case .updateComposeAction(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .updateUserStatus?: try {
      guard case .updateUserStatus(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .messageAttachment?: try {
      guard case .messageAttachment(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .updateReaction?: try {
      guard case .updateReaction(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .deleteReaction?: try {
      guard case .deleteReaction(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .participantAdd?: try {
      guard case .participantAdd(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .participantDelete?: try {
      guard case .participantDelete(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .newChat?: try {
      guard case .newChat(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .deleteChat?: try {
      guard case .deleteChat(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .spaceMemberAdd?: try {
      guard case .spaceMemberAdd(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .spaceMemberDelete?: try {
      guard case .spaceMemberDelete(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .joinSpace?: try {
      guard case .joinSpace(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .updateReadMaxID?: try {
      guard case .updateReadMaxID(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .updateUserSettings?: try {
      guard case .updateUserSettings(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .newMessageNotification?: try {
      guard case .newMessageNotification(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Update, rhs: Update) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateNewMessageNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateNewMessageNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reason != .unspecified {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateNewMessageNotification, rhs: UpdateNewMessageNotification) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateNewMessageNotification.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REASON_UNSPECIFIED"),
    1: .same(proto: "REASON_MENTION"),
    2: .same(proto: "REASON_IMPORTANT"),
  ]
}

extension UpdateUserSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateUserSettings, rhs: UpdateUserSettings) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateSpaceMemberAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateSpaceMemberAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _member: Member? = nil
    var _user: User? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _member = source._member
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._member) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._member {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateSpaceMemberAdd, rhs: UpdateSpaceMemberAdd) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._member != rhs_storage._member {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateSpaceMemberDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateSpaceMemberDelete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateSpaceMemberDelete, rhs: UpdateSpaceMemberDelete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateJoinSpace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateJoinSpace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "space"),
    2: .same(proto: "member"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._space) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._space {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateJoinSpace, rhs: UpdateJoinSpace) -> Bool {
    if lhs._space != rhs._space {return false}
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateReadMaxId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateReadMaxId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    3: .standard(proto: "read_max_id"),
    4: .standard(proto: "unread_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.readMaxID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.unreadCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.readMaxID != 0 {
      try visitor.visitSingularInt64Field(value: self.readMaxID, fieldNumber: 3)
    }
    if self.unreadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.unreadCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateReadMaxId, rhs: UpdateReadMaxId) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.readMaxID != rhs.readMaxID {return false}
    if lhs.unreadCount != rhs.unreadCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateNewChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateNewChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chat"),
    3: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _chat: Chat? = nil
    var _user: User? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _chat = source._chat
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._chat) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._chat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateNewChat, rhs: UpdateNewChat) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chat != rhs_storage._chat {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateDeleteChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateDeleteChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateDeleteChat, rhs: UpdateDeleteChat) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateNewMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateNewMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateNewMessage, rhs: UpdateNewMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateEditMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateEditMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateEditMessage, rhs: UpdateEditMessage) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateDeleteMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateDeleteMessages"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_ids"),
    2: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.messageIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.messageIds, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateDeleteMessages, rhs: UpdateDeleteMessages) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateMessageId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateMessageId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "random_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.randomID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    if self.randomID != 0 {
      try visitor.visitSingularInt64Field(value: self.randomID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateMessageId, rhs: UpdateMessageId) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.randomID != rhs.randomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateComposeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateComposeAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "peer_id"),
    3: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.action != .none {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateComposeAction, rhs: UpdateComposeAction) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateComposeAction.ComposeAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "TYPING"),
    2: .same(proto: "UPLOADING_PHOTO"),
    3: .same(proto: "UPLOADING_DOCUMENT"),
    4: .same(proto: "UPLOADING_VIDEO"),
  ]
}

extension UpdateMessageAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateMessageAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachment"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "peer_id"),
    50: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 50: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 2)
    }
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 50)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateMessageAttachment, rhs: UpdateMessageAttachment) -> Bool {
    if lhs._attachment != rhs._attachment {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._peerID != rhs._peerID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateReaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateReaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateReaction, rhs: UpdateReaction) -> Bool {
    if lhs._reaction != rhs._reaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateDeleteReaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateDeleteReaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "chat_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateDeleteReaction, rhs: UpdateDeleteReaction) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateUserStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateUserStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateUserStatus, rhs: UpdateUserStatus) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChatParticipant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatParticipant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.date != 0 {
      try visitor.visitSingularInt64Field(value: self.date, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ChatParticipant, rhs: ChatParticipant) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateChatParticipantAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateChatParticipantAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .same(proto: "participant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateChatParticipantAdd, rhs: UpdateChatParticipantAdd) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateChatParticipantDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateChatParticipantDelete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateChatParticipantDelete, rhs: UpdateChatParticipantDelete) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "online"),
    2: .standard(proto: "last_online"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.online) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastOnline) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.online != .unknown {
      try visitor.visitSingularEnumField(value: self.online, fieldNumber: 1)
    }
    try { if let v = self._lastOnline {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserStatus, rhs: UserStatus) -> Bool {
    if lhs.online != rhs.online {return false}
    if lhs._lastOnline != rhs._lastOnline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserStatus.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONLINE"),
    2: .same(proto: "OFFLINE"),
  ]
}

extension LastOnline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LastOnline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LastOnline, rhs: LastOnline) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteChatInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteChatInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteChatInput, rhs: DeleteChatInput) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteChatResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteChatResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeleteChatResult, rhs: DeleteChatResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InviteToSpaceInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InviteToSpaceInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "space_id"),
    2: .same(proto: "role"),
    3: .standard(proto: "user_id"),
    4: .same(proto: "email"),
    5: .standard(proto: "phone_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.spaceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.via != nil {try decoder.handleConflictingOneOf()}
          self.via = .userID(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.via != nil {try decoder.handleConflictingOneOf()}
          self.via = .email(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.via != nil {try decoder.handleConflictingOneOf()}
          self.via = .phoneNumber(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.spaceID != 0 {
      try visitor.visitSingularInt64Field(value: self.spaceID, fieldNumber: 1)
    }
    if self.role != .owner {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    switch self.via {
    case .userID?: try {
      guard case .userID(let v)? = self.via else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .email?: try {
      guard case .email(let v)? = self.via else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .phoneNumber?: try {
      guard case .phoneNumber(let v)? = self.via else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InviteToSpaceInput, rhs: InviteToSpaceInput) -> Bool {
    if lhs.spaceID != rhs.spaceID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.via != rhs.via {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InviteToSpaceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InviteToSpaceResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "member"),
    3: .same(proto: "chat"),
    4: .same(proto: "dialog"),
  ]

  fileprivate class _StorageClass {
    var _user: User? = nil
    var _member: Member? = nil
    var _chat: Chat? = nil
    var _dialog: Dialog? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _member = source._member
      _chat = source._chat
      _dialog = source._dialog
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._member) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._chat) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dialog) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._member {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._chat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dialog {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: InviteToSpaceResult, rhs: InviteToSpaceResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._member != rhs_storage._member {return false}
        if _storage._chat != rhs_storage._chat {return false}
        if _storage._dialog != rhs_storage._dialog {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatParticipantsInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatParticipantsInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatParticipantsInput, rhs: GetChatParticipantsInput) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetChatParticipantsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GetChatParticipantsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "participants"),
    2: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.participants) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participants.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.participants, fieldNumber: 1)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GetChatParticipantsResult, rhs: GetChatParticipantsResult) -> Bool {
    if lhs.participants != rhs.participants {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddChatParticipantInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddChatParticipantInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddChatParticipantInput, rhs: AddChatParticipantInput) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddChatParticipantResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddChatParticipantResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "participant"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddChatParticipantResult, rhs: AddChatParticipantResult) -> Bool {
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoveChatParticipantInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RemoveChatParticipantInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_id"),
    2: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.chatID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatID != 0 {
      try visitor.visitSingularInt64Field(value: self.chatID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RemoveChatParticipantInput, rhs: RemoveChatParticipantInput) -> Bool {
    if lhs.chatID != rhs.chatID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoveChatParticipantResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RemoveChatParticipantResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RemoveChatParticipantResult, rhs: RemoveChatParticipantResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DraftMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DraftMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "entities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try { if let v = self._entities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DraftMessage, rhs: DraftMessage) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._entities != rhs._entities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
